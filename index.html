<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Alchemy - Stable Grab</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .ui-element { pointer-events: auto; z-index: 20; user-select: none; display: flex; justify-content: center; align-items: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); border: 3px solid white; }
        
        /* UI配置 */
        #spawn-btn { position: absolute; right: 20px; bottom: 80px; width: 80px; height: 80px; background: #2196F3; color: white; border-radius: 50%; font-weight: bold; font-size: 14px; }
        #spawn-btn:active { transform: scale(0.9); background: #1976D2; }
        
        #jump-btn { position: absolute; left: 160px; bottom: 40px; width: 80px; height: 60px; background: #ff9800; color: white; border-radius: 8px; font-weight: bold; font-size: 14px; }
        #jump-btn:active { transform: scale(0.9); background: #e68900; }

        #alchemy-btn { position: absolute; right: 120px; bottom: 40px; width: 80px; height: 60px; background: #795548; color: white; border-radius: 8px; font-weight: bold; font-size: 12px; }
        #alchemy-btn:active { transform: scale(0.9); background: #5D4037; border-color: #ffcc00; }

        #joystick-zone { position: absolute; left: 20px; bottom: 40px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; border: none; box-shadow: none; }
        #look-zone { position: absolute; top: 0; right: 0; bottom: 0; left: 40%; pointer-events: auto; z-index: 9; }
        
        #vr-instructions { position: absolute; top: 15%; width: 100%; text-align: center; color: white; font-size: 1.1em; text-shadow: 1px 1px 2px black; pointer-events: none; display: none; line-height: 1.8; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="look-zone"></div>
        <div id="joystick-zone" class="ui-element"><div id="joystick-knob"></div></div>
        <div id="jump-btn" class="ui-element">JUMP</div>
        <div id="alchemy-btn" class="ui-element">錬成<br>(長押し)</div>
        <div id="spawn-btn" class="ui-element">DROP</div>
        
        <div id="vr-instructions">
            左スティック: 移動 / 左トリガー: 出す<br>
            右スティック: 回転 / 右トリガー: 掴む・投げる<br>
            <span style="color: #ffcc00; font-weight: bold;">★左右トリガー同時押し：エレベーター錬成</span>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // --- 設定 ---
        const timeStep = 1 / 60;
        const objects = [];
        const input = { x: 0, y: 0 };
        const cameraAngle = { pitch: 0, yaw: 0 };
        const maxObjects = 250;
        let isVR = false;
        const eyeHeightOffset = 1.3; 
        const turnSpeed = 2.0;

        // --- 物理エンジン ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.solver.iterations = 20; // 安定性重視
        const physicsMat = new CANNON.Material();
        const contactMat = new CANNON.ContactMaterial(physicsMat, physicsMat, { friction: 0.5, restitution: 0.1 });
        world.addContactMaterial(contactMat);

        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: physicsMat });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);
        
        const playerHeight = 1.7;
        const playerRadius = 0.3;
        const playerBody = new CANNON.Body({ mass: 80, shape: new CANNON.Sphere(playerRadius), material: physicsMat, fixedRotation: true, linearDamping: 0.95 });
        playerBody.position.set(0, 5, 0);
        world.addBody(playerBody);

        let canJump = true;
        const jumpImpulse = 400;
        const moveSpeed = 6.0;

        // --- グラフィックス ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccee);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const dolly = new THREE.Group();
        scene.add(dolly);
        dolly.add(camera);
        dolly.position.set(0, playerHeight, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local-floor');
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const groundMesh = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 }) );
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // 壁
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
        const wallPhysMat = new CANNON.Material({friction: 0.1, restitution: 0});
        const halfExtent = 25; const wallHeight = 5; const wallThickness = 1.0;
        const createWall = (x, z, w, d) => {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, wallHeight*2, d), wallMat);
            mesh.position.set(x, wallHeight, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(w/2, wallHeight, d/2)), material: wallPhysMat });
            body.position.set(x, wallHeight, z);
            world.addBody(body);
        };
        createWall(halfExtent, 0, wallThickness, halfExtent*2 + wallThickness*2);
        createWall(-halfExtent, 0, wallThickness, halfExtent*2 + wallThickness*2);
        createWall(0, halfExtent, halfExtent*2, wallThickness);
        createWall(0, -halfExtent, halfExtent*2, wallThickness);

        // --- VRコントローラー ---
        const controller1 = renderer.xr.getController(0);
        const controller2 = renderer.xr.getController(1);
        dolly.add(controller1);
        dolly.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();
        const grip1 = renderer.xr.getControllerGrip(0); grip1.add(controllerModelFactory.createControllerModel(grip1)); dolly.add(grip1);
        const grip2 = renderer.xr.getControllerGrip(1); grip2.add(controllerModelFactory.createControllerModel(grip2)); dolly.add(grip2);
        
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
        const line1 = new THREE.Line(lineGeo); line1.scale.z = 5; controller1.add(line1);
        
        // --- ★ 錬金術エレベーターロジック ---
        let isAlchemyActive = false;
        let activePillar = null;
        const alchemySpeed = 8.0; 

        function startAlchemy() {
            if (activePillar) return; 

            // プレイヤーの真下からスタート
            const spawnPos = playerBody.position.clone();
            spawnPos.y = 0; 

            const width = 1.5; 
            const depth = 1.5;
            
            const geo = new THREE.BoxGeometry(width, 1, depth);
            const mat = new THREE.MeshStandardMaterial({ color: 0x8D6E63, roughness: 1.0 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(spawnPos);
            mesh.scale.y = 0.1; 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const body = new CANNON.Body({ 
                mass: 0, 
                type: CANNON.Body.KINEMATIC, 
                shape: new CANNON.Box(new CANNON.Vec3(width/2, 0.1, depth/2)),
                material: physicsMat
            });
            body.position.copy(spawnPos);
            world.addBody(body);

            activePillar = { mesh, body, currentHeight: 0, width, depth, spawnPos };
        }

        function updateAlchemy(dt) {
            if (!activePillar) return;

            if (isAlchemyActive) {
                // 上昇
                activePillar.body.velocity.set(0, alchemySpeed, 0);
                activePillar.currentHeight = activePillar.body.position.y;
                activePillar.mesh.position.y = activePillar.currentHeight / 2;
                activePillar.mesh.scale.y = activePillar.currentHeight;
            } else {
                // 固定化
                const finalHeight = activePillar.currentHeight;
                if (finalHeight > 0.2) {
                    const staticBody = new CANNON.Body({
                        mass: 0,
                        shape: new CANNON.Box(new CANNON.Vec3(activePillar.width/2, finalHeight/2, activePillar.depth/2)),
                        material: physicsMat
                    });
                    staticBody.position.set(activePillar.spawnPos.x, finalHeight/2, activePillar.spawnPos.z);
                    world.addBody(staticBody);
                    objects.push({ mesh: activePillar.mesh, body: staticBody });
                } else {
                    scene.remove(activePillar.mesh);
                }
                world.removeBody(activePillar.body);
                activePillar = null;
            }
        }

        // --- 掴む機能 (回転防止強化版) ---
        let grabbedObject = null;
        let grabConstraint = null;
        
        // 手のボディ
        const handBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
        handBody.collisionFilterGroup = 0; handBody.collisionFilterMask = 0; 
        world.addBody(handBody);

        const controllerPosPrev = new THREE.Vector3(); 
        const controllerPosCurr = new THREE.Vector3(); 
        const controllerVelocity = new THREE.Vector3();

        // 左トリガー: ドロップ
        controller1.addEventListener('selectstart', () => {
            const tempMatrix = new THREE.Matrix4(); tempMatrix.identity().extractRotation(controller1.matrixWorld);
            const dir = new THREE.Vector3(0, 0, -1).applyMatrix4(tempMatrix);
            const pos = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
            spawnObject(pos, dir);
        });

        // 右トリガー: 掴む
        controller2.addEventListener('selectstart', () => {
            if (grabbedObject) return;
            const pos = controller2.getWorldPosition(new THREE.Vector3());
            let closest = 1.5, target = null;
            for (const obj of objects) { const d = pos.distanceTo(obj.mesh.position); if (d < closest && obj.body.mass > 0) { closest = d; target = obj.body; } }
            
            if (target) {
                grabbedObject = target; 
                handBody.position.copy(pos);
                grabConstraint = new CANNON.PointToPointConstraint(handBody, new CANNON.Vec3(0,0,0), grabbedObject, new CANNON.Vec3(0,0,0));
                world.addConstraint(grabConstraint);
                
                // ★ 回転防止対策: 掴んだ瞬間に回転抵抗(Damping)を極端に上げる
                grabbedObject.angularDamping = 0.99; 
            }
        });

        controller2.addEventListener('selectend', () => {
            if (grabbedObject && grabConstraint) {
                world.removeConstraint(grabConstraint); 
                grabConstraint = null;
                
                // 投げる
                grabbedObject.velocity.set(controllerVelocity.x * 2.0, controllerVelocity.y * 2.0, controllerVelocity.z * 2.0);
                
                // ★ 回転抵抗を元に戻す（空中で自然に回転するように）
                grabbedObject.angularDamping = 0.01;
                
                // 少し回転を加える
                grabbedObject.angularVelocity.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).scale(5);
                
                grabbedObject = null;
            }
        });

        // --- オブジェクト生成 ---
        function spawnObject(position, direction) {
            if (!position) {
                direction = new THREE.Vector3(); camera.getWorldDirection(direction);
                position = new THREE.Vector3().copy(dolly.position).add(new THREE.Vector3(0, 2, 0)).add(direction.clone().multiplyScalar(1));
            }
            const spawnPos = position.clone().add(direction ? direction.multiplyScalar(0.5) : new THREE.Vector3());
            const size = Math.random() * 1.5 + 0.3;
            const r = Math.random(); let geo, shape;
            if (r < 0.4) { geo = new THREE.BoxGeometry(size, size, size); shape = new CANNON.Box(new CANNON.Vec3(size/2, size/2, size/2)); } 
            else if (r < 0.7) { geo = new THREE.SphereGeometry(size/2); shape = new CANNON.Sphere(size/2); } 
            else { geo = new THREE.CylinderGeometry(size/2, size/2, size); shape = new CANNON.Cylinder(size/2, size/2, size); }
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.7 }));
            mesh.position.copy(spawnPos); mesh.castShadow = true; scene.add(mesh);
            const body = new CANNON.Body({ mass: size * 10, shape: shape, material: physicsMat });
            body.position.copy(spawnPos); body.quaternion.setFromAxisAngle(new CANNON.Vec3(Math.random(), Math.random(), Math.random()).unit(), Math.random() * Math.PI);
            world.addBody(body); objects.push({ mesh, body });
            if (objects.length > maxObjects) { const old = objects.shift(); scene.remove(old.mesh); world.removeBody(old.body); }
        }

        // --- UI Events ---
        const uiContainer = document.getElementById('ui-container');
        const vrInstructions = document.getElementById('vr-instructions');
        const jumpBtn = document.getElementById('jump-btn');
        const spawnBtn = document.getElementById('spawn-btn');
        const alchemyBtn = document.getElementById('alchemy-btn');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const lookZone = document.getElementById('look-zone');

        renderer.xr.addEventListener('sessionstart', () => { isVR = true; uiContainer.querySelectorAll('.ui-element').forEach(el => el.style.display = 'none'); vrInstructions.style.display = 'block'; });
        renderer.xr.addEventListener('sessionend', () => { isVR = false; uiContainer.querySelectorAll('.ui-element').forEach(el => el.style.display = 'flex'); vrInstructions.style.display = 'none'; });

        spawnBtn.addEventListener('click', () => spawnObject()); spawnBtn.addEventListener('touchstart', (e) => { e.preventDefault(); spawnObject(); }, { passive: false });
        
        const doJump = () => { if (canJump) { playerBody.applyImpulse(new CANNON.Vec3(0, jumpImpulse, 0), playerBody.position); canJump = false; } };
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); doJump(); }, { passive: false });
        
        alchemyBtn.addEventListener('touchstart', (e) => { e.preventDefault(); isAlchemyActive = true; startAlchemy(); }, { passive: false });
        alchemyBtn.addEventListener('touchend', (e) => { e.preventDefault(); isAlchemyActive = false; }, { passive: false });


        let joyId = null, joyCenter = { x: 0, y: 0 };
        joystickZone.addEventListener('touchstart', (e) => { e.preventDefault(); const t = e.changedTouches[0]; joyId = t.identifier; const rect = joystickZone.getBoundingClientRect(); joyCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }; moveJoy(t.clientX, t.clientY); }, { passive: false });
        joystickZone.addEventListener('touchmove', (e) => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joyId) moveJoy(e.changedTouches[i].clientX, e.changedTouches[i].clientY); } }, { passive: false });
        joystickZone.addEventListener('touchend', (e) => { e.preventDefault(); input.x = 0; input.y = 0; joystickKnob.style.transform = `translate(-50%, -50%)`; }, { passive: false });
        function moveJoy(x, y) { const maxR = 40; let dx = x - joyCenter.x; let dy = y - joyCenter.y; const dist = Math.sqrt(dx*dx + dy*dy); if(dist > maxR) { dx = (dx/dist)*maxR; dy = (dy/dist)*maxR; } joystickKnob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`; input.x = dx / maxR; input.y = dy / maxR; }

        let lastX, lastY;
        lookZone.addEventListener('touchstart', (e) => { lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; }, { passive: false });
        lookZone.addEventListener('touchmove', (e) => { e.preventDefault(); const x = e.touches[0].clientX; const y = e.touches[0].clientY; if (lastX != null) { cameraAngle.yaw -= (x - lastX) * 0.005; cameraAngle.pitch -= (y - lastY) * 0.005; cameraAngle.pitch = Math.max(-1.5, Math.min(1.5, cameraAngle.pitch)); } lastX = x; lastY = y; }, { passive: false });
        lookZone.addEventListener('touchend', () => { lastX = null; lastY = null; });

        // --- メインループ ---
        const clock = new THREE.Clock();
        let jumpButtonPressedPrev = false;

        renderer.setAnimationLoop(() => {
            const dt = Math.min(clock.getDelta(), 0.1);

            if (isVR) {
                controller2.getWorldPosition(controllerPosCurr);
                if (grabConstraint) {
                    handBody.position.copy(controllerPosCurr);
                    // ★ 掴んでいる間、回転速度を強制的にゼロにする（暴れ防止）
                    if(grabbedObject) {
                        grabbedObject.angularVelocity.set(0,0,0);
                    }
                }
                controllerVelocity.subVectors(controllerPosCurr, controllerPosPrev).divideScalar(dt);
                controllerPosPrev.copy(controllerPosCurr);

                // --- ★ 錬金術判定 (L+R トリガー同時押し) ---
                let lTrig = false, rTrig = false;
                const session = renderer.xr.getSession();
                if (session && session.inputSources) {
                    for (const source of session.inputSources) {
                        if (!source.gamepad) continue;
                        if (source.handedness === 'left') { if(source.gamepad.buttons[0].pressed) lTrig = true; }
                        if (source.handedness === 'right') { if(source.gamepad.buttons[0].pressed) rTrig = true; }
                    }
                }
                
                // 両方のトリガーが押されている場合のみ発動
                if (lTrig && rTrig) {
                    if (!isAlchemyActive) {
                        isAlchemyActive = true;
                        startAlchemy();
                    }
                } else {
                    isAlchemyActive = false;
                }
            }
            
            // 錬金術エレベーターの更新
            updateAlchemy(dt);
            
            world.step(timeStep, dt, 5);
            if (playerBody.position.y <= playerRadius + 0.15) canJump = true;

            if (isVR) {
                // VR Inputs
                let vrMoveX = 0, vrMoveZ = 0, vrRotX = 0;
                let jumpButtonPressed = false;
                const session = renderer.xr.getSession();
                if (session && session.inputSources) {
                    for (const source of session.inputSources) {
                        if (!source.gamepad) if (source.handedness === 'left') { 
    const axes = source.gamepad.axes;

    // 左スティック位置の自動判別
    if (axes.length >= 4) {
        const lx = Math.abs(axes[0]) + Math.abs(axes[1]);
        const rx = Math.abs(axes[2]) + Math.abs(axes[3]);

        if (lx > rx) {
            vrMoveX = axes[0];
            vrMoveZ = -axes[1];
        } else {
            vrMoveX = axes[2];
            vrMoveZ = -axes[3];
        }
    }
}
                        if (source.handedness === 'right') { // Rotate & Jump
                            const axes = source.gamepad.axes; if (axes.length >= 4) { vrRotX = axes[2]; }
                            const btns = source.gamepad.buttons; if ((btns[4] && btns[4].pressed) || (btns[3] && btns[3].pressed)) { jumpButtonPressed = true; }
                        }
                    }
                }

                if (jumpButtonPressed && !jumpButtonPressedPrev) doJump();
                jumpButtonPressedPrev = jumpButtonPressed;

                if (Math.abs(vrRotX) > 0.1) {
                    dolly.rotation.y -= vrRotX * turnSpeed * dt;
                }

                // デッドゾーン
                const deadZone = 0.05;
                const mag = Math.sqrt(vrMoveX*vrMoveX + vrMoveZ*vrMoveZ);
                if (mag > deadZone) {
                    // スティックの強さで速度をスケール（normalize を使わない）
                    const strength = Math.min(1, (mag - deadZone) / (1 - deadZone)); // deadzone後の 0..1
                    // 視点に対しての前/右ベクトル
                    const headRotY = dolly.rotation.y + new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ').y;
                    const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), headRotY);
                    const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), headRotY);

                    // そのまま合成（スティックの比率を保つ）
                    const moveVec = new THREE.Vector3().addScaledVector(right, vrMoveX).addScaledVector(forward, vrMoveZ);
                    // スケールを strength * moveSpeed にする
                    moveVec.setLength(moveSpeed * strength);

                    // 緩やかな反映（スムース）
                    playerBody.velocity.x = moveVec.x * 0.8 + playerBody.velocity.x * 0.2;
                    playerBody.velocity.z = moveVec.z * 0.8 + playerBody.velocity.z * 0.2;
                } else {
                    // ブレーキ
                    playerBody.velocity.x *= 0.9; playerBody.velocity.z *= 0.9;
                }
            } else {
                // Mobile
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.yaw);
                const moveVec = new THREE.Vector3().addScaledVector(right, input.x).addScaledVector(forward, -input.y).normalize().multiplyScalar(moveSpeed);
                playerBody.velocity.x = moveVec.x; playerBody.velocity.z = moveVec.z;
                camera.rotation.set(cameraAngle.pitch, cameraAngle.yaw, 0, 'YXZ');
            }
            
            dolly.position.copy(playerBody.position);
            dolly.position.y -= playerRadius; dolly.position.y += eyeHeightOffset;

            for (const obj of objects) { obj.mesh.position.copy(obj.body.position); obj.mesh.quaternion.copy(obj.body.quaternion); }
            renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
