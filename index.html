<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Meta Quest 2 WebXR Emulator</title>
<style>
    /* --- 全体スタイル --- */
    :root {
        --bg-color: #121212;
        --editor-bg: #1e1e1e;
        --text-color: #e0e0e0;
        --accent-color: #007acc;
        --danger-color: #d32f2f;
        --ui-bg: rgba(20, 20, 20, 0.85);
        --zone-bg: rgba(50, 50, 50, 0.4);
    }
    body {
        margin: 0; padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    button, select { touch-action: manipulation; }

    /* --- エディタ画面 --- */
    #editor-screen {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 8px;
        box-sizing: border-box;
    }
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
        justify-content: space-between;
    }
    .toolbar-group {
        display: flex;
        gap: 6px;
    }
    select {
        background: #333; color: #fff; border: 1px solid #555;
        padding: 6px; border-radius: 4px;
    }
    .btn {
        background: #333; color: #fff; border: 1px solid #555;
        padding: 6px 12px; border-radius: 4px; font-size: 13px; cursor: pointer;
    }
    .btn:active { background: #555; }
    .btn-run { background: #2e7d32; border-color: #1b5e20; width: 100%; padding: 12px; font-weight: bold; font-size: 16px; margin-top: 5px; }
    .btn-danger { background: var(--danger-color); border-color: #b71c1c; }

    #code-area {
        flex-grow: 1;
        background-color: var(--editor-bg);
        color: #f8f8f2;
        border: 1px solid #444;
        padding: 10px;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 12px;
        resize: none;
        outline: none;
        border-radius: 4px;
        white-space: pre;
        overflow: auto;
    }

    /* --- エミュレータ画面 --- */
    #emulator-screen {
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #000;
        z-index: 100;
    }
    #vr-frame { width: 100%; height: 100%; border: none; display: block; }

    /* --- オーバーレイUI --- */
    #ui-header {
        position: absolute; top: 0; left: 0; width: 100%;
        padding: 10px; box-sizing: border-box;
        display: flex; justify-content: space-between; align-items: flex-start;
        pointer-events: none; /* ボタン以外は透過 */
    }
    #exit-btn {
        pointer-events: auto;
        background: rgba(200, 0, 0, 0.8); color: white;
        border: 2px solid white; border-radius: 50%;
        width: 36px; height: 36px;
        display: flex; justify-content: center; align-items: center;
        font-weight: bold; cursor: pointer;
    }
    #status-display {
        background: rgba(0,0,0,0.6); color: #0f0;
        font-size: 11px; padding: 4px 8px; border-radius: 4px;
        text-align: right;
    }

    /* コントロールパネル */
    #controls-overlay {
        position: absolute; bottom: 0; left: 0; width: 100%;
        height: 38%; /* 画面下部38%を使用 */
        background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0));
        display: flex; justify-content: space-around; align-items: flex-end;
        padding: 10px 5px; box-sizing: border-box;
        pointer-events: none; /* 隙間はタッチスルー */
    }

    .control-zone {
        pointer-events: auto;
        background: var(--zone-bg);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 12px;
        padding: 6px;
        display: flex; flex-direction: column; align-items: center;
        gap: 6px;
        width: 32%; height: 100%;
        box-sizing: border-box;
    }
    .zone-label { color: #aaa; font-size: 10px; font-weight: bold; margin-bottom: 2px; }

    /* トラッキングパッド */
    .track-pad {
        flex-grow: 1; width: 100%;
        background: rgba(0,0,0,0.3);
        border: 1px dashed rgba(255,255,255,0.3);
        border-radius: 8px;
        position: relative; touch-action: none;
    }
    .track-knob {
        width: 16px; height: 16px;
        background: #ffeb3b;
        border: 2px solid #fff;
        border-radius: 50%;
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-shadow: 0 0 5px rgba(255, 235, 59, 0.8);
    }
    
    /* ボタン群 */
    .btn-row { display: flex; gap: 8px; justify-content: center; width: 100%; }
    .vr-btn {
        width: 38px; height: 38px;
        background: rgba(255,255,255,0.15);
        border: 1px solid rgba(255,255,255,0.4);
        border-radius: 50%;
        color: white; font-size: 11px; font-weight: bold;
        display: flex; justify-content: center; align-items: center;
        user-select: none;
    }
    .vr-btn:active { background: var(--accent-color); border-color: #fff; }
    .vr-btn.wide { width: 100%; border-radius: 6px; height: 30px; }

    /* ジョイスティック */
    #joy-bg {
        width: 70px; height: 70px;
        background: rgba(255,255,255,0.1);
        border-radius: 50%;
        position: relative; touch-action: none;
        margin: auto;
    }
    #joy-stick {
        width: 30px; height: 30px;
        background: var(--accent-color);
        border-radius: 50%;
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }

</style>
</head>
<body>

    <div id="editor-screen">
        <div class="toolbar">
            <div class="toolbar-group">
                <select id="slot-select">
                    <option value="1">Slot 1</option>
                    <option value="2">Slot 2</option>
                    <option value="3">Slot 3</option>
                    <option value="4">Slot 4</option>
                    <option value="5">Slot 5</option>
                </select>
                <button class="btn" onclick="app.io.save()">保存</button>
                <button class="btn" onclick="app.io.load()">読込</button>
            </div>
            <div class="toolbar-group">
                <button class="btn" onclick="app.io.copy()">Copy</button>
                <button class="btn" onclick="app.io.paste()">Paste</button>
                <button class="btn btn-danger" onclick="app.io.clear()">Clear</button>
            </div>
        </div>
        
        <textarea id="code-area" spellcheck="false" placeholder="ここにWebXR対応HTMLコードを貼り付け"></textarea>
        <button class="btn btn-run" onclick="app.system.run()">▶ VRモード起動</button>
    </div>

    <div id="emulator-screen">
        <div id="ui-header">
            <div id="exit-btn" onclick="app.system.exit()">×</div>
            <div id="status-display">Waiting for Gyro...</div>
        </div>
        
        <iframe id="vr-frame"></iframe>

        <div id="controls-overlay">
            
            <div class="control-zone">
                <span class="zone-label">L-Hand (Pos)</span>
                <div class="track-pad" id="pad-left">
                    <div class="track-knob" id="knob-left"></div>
                </div>
                <div class="btn-row">
                    <div class="vr-btn" data-hand="left" data-key="X">X</div>
                    <div class="vr-btn" data-hand="left" data-key="Y">Y</div>
                </div>
                <div class="btn-row">
                    <div class="vr-btn" data-hand="left" data-key="trigger">Tr</div>
                    <div class="vr-btn" data-hand="left" data-key="grip">Gr</div>
                </div>
            </div>

            <div class="control-zone" style="width: 28%;">
                <span class="zone-label">Move Body</span>
                <div style="flex-grow:1; display:flex; align-items:center;">
                    <div id="joy-bg"><div id="joy-stick"></div></div>
                </div>
                <div class="btn-row">
                    <div class="vr-btn wide" data-hand="left" data-key="menu">MENU</div>
                </div>
            </div>

            <div class="control-zone">
                <span class="zone-label">R-Hand (Pos)</span>
                <div class="track-pad" id="pad-right">
                    <div class="track-knob" id="knob-right"></div>
                </div>
                <div class="btn-row">
                    <div class="vr-btn" data-hand="right" data-key="A">A</div>
                    <div class="vr-btn" data-hand="right" data-key="B">B</div>
                </div>
                <div class="btn-row">
                    <div class="vr-btn" data-hand="right" data-key="trigger">Tr</div>
                    <div class="vr-btn" data-hand="right" data-key="grip">Gr</div>
                </div>
            </div>
            
        </div>
    </div>

    <script>
        // --- 1. Iframe内に注入するWebXR Mockライブラリ ---
        const MOCK_LIB = `
        <script>
        (function() {
            console.log("[VR Mock] Initializing inside Iframe...");
            
            const state = {
                viewer: { position: [0, 1.6, 0], quaternion: [0, 0, 0, 1] },
                inputs: {
                    left:  { axes: [0,0], buttons: {}, position: [-0.2, 1.4, -0.5], quaternion: [0,0,0,1] },
                    right: { axes: [0,0], buttons: {}, position: [ 0.2, 1.4, -0.5], quaternion: [0,0,0,1] }
                }
            };

            // 親ウィンドウからのデータ受信
            window.addEventListener('message', (e) => {
                const msg = e.data;
                if (!msg || msg.source !== 'VR_HOST') return;

                if (msg.type === 'pose') {
                    if (msg.viewer) state.viewer = msg.viewer;
                    if (msg.left)  Object.assign(state.inputs.left, msg.left);
                    if (msg.right) Object.assign(state.inputs.right, msg.right);
                    
                    // ボタン状態の更新
                    if (msg.buttons) {
                        const target = state.inputs[msg.hand].buttons;
                        Object.assign(target, msg.buttons);
                    }
                    // Joystick (Axes) の更新
                    if (msg.axes && msg.hand) {
                        state.inputs[msg.hand].axes = msg.axes;
                    }
                }
            });

            // WebXR API Mock
            class MockXRSession {
                constructor() {
                    this.ended = false;
                    this.inputSources = [ this._createInput('left'), this._createInput('right') ];
                    this.viewerSpace = { name: 'viewer' };
                }
                _createInput(hand) {
                    return {
                        handedness: hand,
                        targetRayMode: 'tracked-pointer',
                        profiles: ['oculus-touch-v3', 'oculus-touch-v2', 'oculus-touch'],
                        gamepad: {
                            buttons: Array(7).fill(0).map(()=>({pressed:false, value:0})),
                            axes: [0, 0]
                        }
                    };
                }
                _syncInput(hand, index) {
                    const src = this.inputSources[index];
                    const data = state.inputs[hand];
                    const map = (b) => ({ pressed: !!b, value: b?1:0 });
                    
                    src.gamepad.axes = data.axes;
                    const btns = src.gamepad.buttons;
                    // Standard Oculus Mapping
                    btns[0] = map(data.buttons.trigger); // Trigger
                    btns[1] = map(data.buttons.grip);    // Grip
                    btns[3] = map(hand==='left' ? data.buttons.X : data.buttons.A); // Thumbstick Click? or A/X
                    btns[4] = map(hand==='left' ? data.buttons.Y : data.buttons.B); // B/Y
                    btns[5] = map(data.buttons.menu);    // Menu
                }
                requestReferenceSpace(t) { return Promise.resolve(this.viewerSpace); }
                updateRenderState(p) {}
                end() { this.ended=true; return Promise.resolve(); }
                
                requestAnimationFrame(cb) {
                    if(this.ended) return 0;
                    return window.requestAnimationFrame(t => {
                        this._syncInput('left', 0);
                        this._syncInput('right', 1);
                        cb(t, {
                            session: this,
                            getViewerPose: () => ({
                                transform: {
                                    position: {x:state.viewer.position[0], y:state.viewer.position[1], z:state.viewer.position[2], w:1},
                                    orientation: {x:state.viewer.quaternion[0], y:state.viewer.quaternion[1], z:state.viewer.quaternion[2], w:state.viewer.quaternion[3]}
                                },
                                views: [{
                                    eye:'left', projectionMatrix:[1.2,0,0,0, 0,2.4,0,0, 0,0,-1,-1, 0,0,-0.2,0],
                                    transform:{position:{x:0,y:0,z:0}, orientation:{x:0,y:0,z:0,w:1}},
                                    viewport:{x:0,y:0, width:window.innerWidth, height:window.innerHeight}
                                }]
                            }),
                            getPose: (src) => {
                                const d = state.inputs[src.handedness];
                                return {
                                    transform: {
                                        position: {x:d.position[0], y:d.position[1], z:d.position[2], w:1},
                                        orientation: {x:d.quaternion[0], y:d.quaternion[1], z:d.quaternion[2], w:d.quaternion[3]}
                                    }
                                };
                            }
                        });
                    });
                }
            }

            const mockXR = {
                isSessionSupported: m => Promise.resolve(m==='immersive-vr'),
                requestSession: m => Promise.resolve(new MockXRSession())
            };
            
            try { Object.defineProperty(navigator, 'xr', { value: mockXR, configurable: true }); }
            catch(e) { window.navigator.xr = mockXR; }
        })();
        <\/script>`;

        // --- 2. ホストアプリケーション ---
        const app = {
            dom: {
                editor: document.getElementById('editor-screen'),
                emulator: document.getElementById('emulator-screen'),
                code: document.getElementById('code-area'),
                frame: document.getElementById('vr-frame'),
                status: document.getElementById('status-display'),
                knobL: document.getElementById('knob-left'),
                knobR: document.getElementById('knob-right'),
                stick: document.getElementById('joy-stick')
            },
            state: {
                viewer: { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 },
                controllers: {
                    left:  { x: -0.2, y: 1.3, z: -0.4 },
                    right: { x:  0.2, y: 1.3, z: -0.4 }
                },
                loopId: null,
                gyroAlpha0: null
            },

            // --- I/O & Storage ---
            io: {
                save: () => {
                    const s = document.getElementById('slot-select').value;
                    localStorage.setItem('vr_kit_s'+s, app.dom.code.value);
                    alert('Saved to Slot '+s);
                },
                load: () => {
                    const s = document.getElementById('slot-select').value;
                    const v = localStorage.getItem('vr_kit_s'+s);
                    if(v) app.dom.code.value = v;
                },
                copy: async () => { await navigator.clipboard.writeText(app.dom.code.value); alert('Copied'); },
                paste: async () => { app.dom.code.value = await navigator.clipboard.readText(); },
                clear: () => { if(confirm('Clear code?')) app.dom.code.value = ''; }
            },

            // --- System ---
            system: {
                init: () => {
                    app.io.load();
                    if(!app.dom.code.value) app.dom.code.value = app.sampleCode;
                    app.controls.init();
                },
                run: async () => {
                    // ジャイロ許可
                    if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try { await DeviceOrientationEvent.requestPermission(); } catch(e){}
                    }
                    
                    app.dom.editor.style.display = 'none';
                    app.dom.emulator.style.display = 'block';
                    
                    // Iframe注入
                    const code = app.dom.code.value.replace('<head>', '<head>' + MOCK_LIB);
                    app.dom.frame.srcdoc = code;

                    // センサーとループ開始
                    window.addEventListener('deviceorientation', app.tracking.onGyro);
                    app.dom.emulator.addEventListener('touchstart', app.tracking.onTouchStart);
                    app.dom.emulator.addEventListener('touchmove', app.tracking.onTouchMove);
                    app.dom.emulator.addEventListener('touchend', app.tracking.onTouchEnd);
                    
                    app.state.loopId = requestAnimationFrame(app.system.loop);
                },
                exit: () => {
                    app.dom.emulator.style.display = 'none';
                    app.dom.editor.style.display = 'flex';
                    app.dom.frame.srcdoc = '';
                    
                    window.removeEventListener('deviceorientation', app.tracking.onGyro);
                    app.dom.emulator.removeEventListener('touchstart', app.tracking.onTouchStart);
                    app.dom.emulator.removeEventListener('touchmove', app.tracking.onTouchMove);
                    cancelAnimationFrame(app.state.loopId);
                    
                    // Reset
                    app.state.viewer = { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 };
                    app.state.gyroAlpha0 = null;
                },
                loop: () => {
                    if(app.dom.emulator.style.display === 'none') return;
                    
                    // 計算: Viewer Quaternion
                    const { yaw, pitch } = app.state.viewer;
                    const q = app.math.eulerToQuat(yaw, pitch, 0); // Yaw, Pitch, Roll
                    
                    // 送信データ構築
                    const msg = {
                        type: 'pose',
                        source: 'VR_HOST',
                        viewer: {
                            position: [app.state.viewer.x, app.state.viewer.y, app.state.viewer.z],
                            quaternion: q
                        },
                        left: {
                            position: [app.state.controllers.left.x, app.state.controllers.left.y, app.state.controllers.left.z]
                        },
                        right: {
                            position: [app.state.controllers.right.x, app.state.controllers.right.y, app.state.controllers.right.z]
                        }
                    };

                    if(app.dom.frame.contentWindow) {
                        app.dom.frame.contentWindow.postMessage(msg, '*');
                    }
                    app.state.loopId = requestAnimationFrame(app.system.loop);
                }
            },

            // --- Controls & Tracking ---
            controls: {
                init: () => {
                    // Buttons
                    document.querySelectorAll('.vr-btn').forEach(btn => {
                        const h = btn.dataset.hand;
                        const k = btn.dataset.key;
                        const send = (p) => {
                            if(app.dom.frame.contentWindow) {
                                app.dom.frame.contentWindow.postMessage({
                                    type:'pose', source:'VR_HOST', hand:h, buttons:{[k]:p}
                                }, '*');
                            }
                        };
                        btn.addEventListener('touchstart', e=>{ e.preventDefault(); e.stopPropagation(); send(true); });
                        btn.addEventListener('touchend',   e=>{ e.preventDefault(); e.stopPropagation(); send(false); });
                    });
                }
            },

            tracking: {
                touches: {}, // touchId -> { type, startX, startY, ... }
                
                onGyro: (e) => {
                    if(e.alpha === null) return;
                    if(app.state.gyroAlpha0 === null) app.state.gyroAlpha0 = e.alpha;
                    
                    // 簡易的な向き計算 (実機に合わせて調整が必要な場合あり)
                    const radA = (e.alpha - app.state.gyroAlpha0) * (Math.PI/180);
                    const radB = (e.beta - 90) * (Math.PI/180); 
                    
                    app.state.viewer.yaw = -radA;
                    app.state.viewer.pitch = radB;
                    app.dom.status.innerText = `Gyro Active: ${Math.round(e.alpha)}`;
                },

                onTouchStart: (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const target = t.target;
                        
                        // Zone判定
                        if(target.closest('#pad-left')) {
                            app.tracking.touches[t.identifier] = { type:'pad', hand:'left', sx:t.clientX, sy:t.clientY, ix:app.state.controllers.left.x, iz:app.state.controllers.left.z };
                        } else if(target.closest('#pad-right')) {
                            app.tracking.touches[t.identifier] = { type:'pad', hand:'right', sx:t.clientX, sy:t.clientY, ix:app.state.controllers.right.x, iz:app.state.controllers.right.z };
                        } else if(target.closest('#joy-bg')) {
                             const rect = document.getElementById('joy-bg').getBoundingClientRect();
                             app.tracking.touches[t.identifier] = { type:'joy', cx:rect.left+rect.width/2, cy:rect.top+rect.height/2 };
                        } else if(!target.closest('#controls-overlay') && target.id !== 'exit-btn') {
                            // 画面外＝スワイプ視点移動（Gyroない場合用）
                            app.tracking.touches[t.identifier] = { type:'swipe', sx:t.clientX, sy:t.clientY };
                        }
                    }
                },
                
                onTouchMove: (e) => {
                    e.preventDefault(); // スクロール防止
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const data = app.tracking.touches[t.identifier];
                        if(!data) continue;

                        if(data.type === 'pad') {
                            const dx = t.clientX - data.sx;
                            const dy = t.clientY - data.sy;
                            const scale = 0.003;
                            // Update State
                            app.state.controllers[data.hand].x = data.ix + dx * scale;
                            app.state.controllers[data.hand].z = data.iz + dy * scale; // Y-swipe maps to Z-depth
                            
                            // Update UI Knob
                            const knob = data.hand==='left' ? app.dom.knobL : app.dom.knobR;
                            const limit = 30; // px
                            const kx = Math.max(-limit, Math.min(limit, dx));
                            const ky = Math.max(-limit, Math.min(limit, dy));
                            knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
                        }
                        else if(data.type === 'joy') {
                            const maxR = 35;
                            let dx = t.clientX - data.cx;
                            let dy = t.clientY - data.cy;
                            const dist = Math.sqrt(dx*dx+dy*dy);
                            if(dist > maxR) { dx *= maxR/dist; dy *= maxR/dist; }
                            
                            // Update UI
                            app.dom.stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                            
                            // Move Viewer
                            const ax = dx/maxR; const ay = dy/maxR;
                            const speed = 0.03;
                            const yaw = app.state.viewer.yaw;
                            app.state.viewer.x += (Math.cos(yaw)*ax - Math.sin(yaw)*ay) * speed;
                            app.state.viewer.z += (Math.sin(yaw)*ax + Math.cos(yaw)*ay) * speed;

                            // Send Axes for compatibility
                            if(app.dom.frame.contentWindow) {
                                app.dom.frame.contentWindow.postMessage({
                                    type:'pose', source:'VR_HOST', hand:'left', axes:[ax, ay]
                                }, '*');
                            }
                        }
                        else if(data.type === 'swipe') {
                            // Gyroが使えない時の予備
                            if(!app.dom.status.innerText.includes('Active')) {
                                const dx = t.clientX - data.sx;
                                const dy = t.clientY - data.sy;
                                app.state.viewer.yaw += dx * 0.005;
                                app.state.viewer.pitch += dy * 0.005;
                                data.sx = t.clientX; data.sy = t.clientY;
                                app.dom.status.innerText = "Swipe Tracking";
                            }
                        }
                    }
                },

                onTouchEnd: (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const data = app.tracking.touches[t.identifier];
                        if(data) {
                            if(data.type === 'joy') {
                                app.dom.stick.style.transform = `translate(-50%, -50%)`;
                                // Reset Axes
                                if(app.dom.frame.contentWindow) {
                                    app.dom.frame.contentWindow.postMessage({
                                        type:'pose', source:'VR_HOST', hand:'left', axes:[0,0]
                                    }, '*');
                                }
                            } else if (data.type === 'pad') {
                                const knob = data.hand==='left' ? app.dom.knobL : app.dom.knobR;
                                knob.style.transform = `translate(-50%, -50%)`;
                            }
                            delete app.tracking.touches[t.identifier];
                        }
                    }
                }
            },

            math: {
                eulerToQuat: (y, p, r) => {
                    const c1=Math.cos(y/2), s1=Math.sin(y/2);
                    const c2=Math.cos(p/2), s2=Math.sin(p/2);
                    const c3=Math.cos(r/2), s3=Math.sin(r/2);
                    return [
                        c1*s2*c3 + s1*c2*s3, // x
                        s1*c2*c3 - c1*s2*s3, // y
                        c1*c2*s3 - s1*s2*c3, // z
                        c1*c2*c3 + s1*s2*s3  // w
                    ];
                }
            },
            
            sampleCode: `<!DOCTYPE html>
<html>
<head>
  <style>body{margin:0;background:#000;}</style>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';

    // 1. Setup Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    // Grid
    scene.add(new THREE.GridHelper(10, 10));

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    
    // Light
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 5, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    // 2. Controller Meshes
    const cGeo = new THREE.BoxGeometry(0.1, 0.1, 0.2);
    const cMatL = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red = Left
    const cMatR = new THREE.MeshLambertMaterial({ color: 0x0000ff }); // Blue = Right
    
    const cLeft = new THREE.Mesh(cGeo, cMatL);
    const cRight = new THREE.Mesh(cGeo, cMatR);
    scene.add(cLeft, cRight);

    // 3. Loop
    renderer.setAnimationLoop((t, frame) => {
        if(!frame) { renderer.render(scene, camera); return; }

        const session = renderer.xr.getSession();
        const refSpace = renderer.xr.getReferenceSpace();
        
        // Update Controller Visuals
        session.inputSources.forEach(src => {
            const pose = frame.getPose(src, refSpace);
            if(pose) {
                const mesh = src.handedness === 'left' ? cLeft : cRight;
                mesh.position.copy(pose.transform.position);
                mesh.quaternion.copy(pose.transform.orientation);
                
                // Button Feedback (Size Change)
                if(src.gamepad.buttons[0].pressed) mesh.scale.set(1.5,1.5,1.5);
                else mesh.scale.set(1,1,1);
            }
        });

        renderer.render(scene, camera);
    });

    // 4. Auto Start
    const start = async () => {
        if(navigator.xr) {
            try {
                const session = await navigator.xr.requestSession('immersive-vr');
                renderer.xr.setSession(session);
            } catch(e) { console.error(e); }
        }
    };
    setTimeout(start, 500);
  <\/script>
</head>
<body></body>
</html>`
        };

        window.onload = app.system.init;
    </script>
</body>
</html>
