<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Physics - Alchemy Update</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .ui-element { pointer-events: auto; z-index: 20; user-select: none; display: flex; justify-content: center; align-items: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); border: 3px solid white; }
        
        /* UI配置 */
        #spawn-btn { position: absolute; right: 20px; bottom: 80px; width: 80px; height: 80px; background: #2196F3; color: white; border-radius: 50%; font-weight: bold; font-size: 14px; }
        #spawn-btn:active { transform: scale(0.9); background: #1976D2; }
        
        #jump-btn { position: absolute; left: 160px; bottom: 40px; width: 80px; height: 60px; background: #ff9800; color: white; border-radius: 8px; font-weight: bold; font-size: 14px; }
        #jump-btn:active { transform: scale(0.9); background: #e68900; }

        #alchemy-btn { position: absolute; right: 120px; bottom: 40px; width: 80px; height: 60px; background: #795548; color: white; border-radius: 8px; font-weight: bold; font-size: 12px; }
        #alchemy-btn:active { transform: scale(0.9); background: #5D4037; }

        #joystick-zone { position: absolute; left: 20px; bottom: 40px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; border: none; box-shadow: none; }
        #look-zone { position: absolute; top: 0; right: 0; bottom: 0; left: 40%; pointer-events: auto; z-index: 9; }
        
        #vr-instructions { position: absolute; top: 15%; width: 100%; text-align: center; color: white; font-size: 1.1em; text-shadow: 1px 1px 2px black; pointer-events: none; display: none; line-height: 1.8; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="look-zone"></div>
        <div id="joystick-zone" class="ui-element"><div id="joystick-knob"></div></div>
        <div id="jump-btn" class="ui-element">JUMP</div>
        <div id="alchemy-btn" class="ui-element">ALCHEMY</div>
        <div id="spawn-btn" class="ui-element">DROP</div>
        
        <div id="vr-instructions">
            左スティック: 移動 / 左トリガー: 出す<br>
            右スティック: 回転 / 右トリガー: 掴む・投げる<br>
            右Aボタン: ジャンプ<br>
            <span style="color: #ffcc00; font-weight: bold;">★両手を地面につけると…？</span>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // --- 設定 ---
        const timeStep = 1 / 60;
        const objects = [];
        const input = { x: 0, y: 0 };
        const cameraAngle = { pitch: 0, yaw: 0 };
        const maxObjects = 250;
        let isVR = false;
        const eyeHeightOffset = 1.3; 
        const turnSpeed = 2.0; // 回転速度

        // --- 物理エンジン ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.solver.iterations = 10;
        const physicsMat = new CANNON.Material();
        const contactMat = new CANNON.ContactMaterial(physicsMat, physicsMat, { friction: 0.4, restitution: 0.3 });
        world.addContactMaterial(contactMat);

        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: physicsMat });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);
        
        const playerHeight = 1.7;
        const playerRadius = 0.3;
        const playerBody = new CANNON.Body({ mass: 80, shape: new CANNON.Sphere(playerRadius), material: physicsMat, fixedRotation: true, linearDamping: 0.95 });
        playerBody.position.set(0, 5, 0);
        world.addBody(playerBody);

        let canJump = true;
        const jumpImpulse = 400;
        const moveSpeed = 6.0;

        // --- グラフィックス ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccee);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const dolly = new THREE.Group();
        scene.add(dolly);
        dolly.add(camera);
        dolly.position.set(0, playerHeight, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local-floor');
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const groundMesh = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 }) );
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // 壁
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
        const wallPhysMat = new CANNON.Material({friction: 0.1, restitution: 0});
        const halfExtent = 25; const wallHeight = 5; const wallThickness = 1.0;
        const createWall = (x, z, w, d) => {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, wallHeight*2, d), wallMat);
            mesh.position.set(x, wallHeight, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(w/2, wallHeight, d/2)), material: wallPhysMat });
            body.position.set(x, wallHeight, z);
            world.addBody(body);
        };
        createWall(halfExtent, 0, wallThickness, halfExtent*2 + wallThickness*2);
        createWall(-halfExtent, 0, wallThickness, halfExtent*2 + wallThickness*2);
        createWall(0, halfExtent, halfExtent*2, wallThickness);
        createWall(0, -halfExtent, halfExtent*2, wallThickness);

        // --- VRコントローラー ---
        const controller1 = renderer.xr.getController(0);
        const controller2 = renderer.xr.getController(1);
        dolly.add(controller1);
        dolly.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();
        const grip1 = renderer.xr.getControllerGrip(0); grip1.add(controllerModelFactory.createControllerModel(grip1)); dolly.add(grip1);
        const grip2 = renderer.xr.getControllerGrip(1); grip2.add(controllerModelFactory.createControllerModel(grip2)); dolly.add(grip2);

        // 光線
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
        const line1 = new THREE.Line(lineGeo); line1.scale.z = 5; controller1.add(line1);
        
        // --- 錬金術ロジック (ハガレン風) ---
        let alchemyCooldown = 0;
        
        function performAlchemy(position) {
            if (alchemyCooldown > 0) return;
            alchemyCooldown = 10; // 連射制限

            // 盛り上がる足場の作成
            const height = Math.random() * 2 + 1.5; // 高さ
            const width = Math.random() * 0.8 + 0.5; // 太さ
            
            // 地面からニョキッと生やす座標
            const spawnPos = position.clone();
            spawnPos.y = height / 2; 

            // ビジュアル
            const geo = new THREE.BoxGeometry(width, height, width);
            const mat = new THREE.MeshStandardMaterial({ color: 0x8D6E63, roughness: 1.0 }); // 土っぽい色
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(spawnPos);
            mesh.castShadow = true; scene.add(mesh);

            // 物理 (Staticにすることで足場として機能する)
            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(width/2, height/2, width/2)), material: physicsMat });
            body.position.copy(spawnPos);
            
            // 少し回転させて自然な岩肌感
            body.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), Math.random() * Math.PI);
            mesh.quaternion.copy(body.quaternion);
            
            world.addBody(body);
            objects.push({ mesh, body }); // 管理リストへ
            
            // 古いものを消す
            if (objects.length > maxObjects) { const old = objects.shift(); scene.remove(old.mesh); world.removeBody(old.body); }
        }

        // --- 掴む機能 ---
        let grabbedObject = null;
        let grabConstraint = null;
        const handBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
        handBody.collisionFilterGroup = 0; handBody.collisionFilterMask = 0; world.addBody(handBody);
        const controllerPosPrev = new THREE.Vector3(); const controllerPosCurr = new THREE.Vector3(); const controllerVelocity = new THREE.Vector3();

        // 左トリガー: ドロップ
        controller1.addEventListener('selectstart', () => {
            const tempMatrix = new THREE.Matrix4(); tempMatrix.identity().extractRotation(controller1.matrixWorld);
            const dir = new THREE.Vector3(0, 0, -1).applyMatrix4(tempMatrix);
            const pos = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
            spawnObject(pos, dir);
        });

        // 右トリガー: 掴む
        controller2.addEventListener('selectstart', () => {
            if (grabbedObject) return;
            const pos = controller2.getWorldPosition(new THREE.Vector3());
            let closest = 1.5, target = null;
            for (const obj of objects) { const d = pos.distanceTo(obj.mesh.position); if (d < closest && obj.body.mass > 0) { closest = d; target = obj.body; } } // mass>0のものだけ掴める(錬成した柱は掴めない)
            if (target) {
                grabbedObject = target; handBody.position.copy(pos);
                grabConstraint = new CANNON.PointToPointConstraint(handBody, new CANNON.Vec3(0,0,0), grabbedObject, new CANNON.Vec3(0,0,0));
                world.addConstraint(grabConstraint);
            }
        });
        controller2.addEventListener('selectend', () => {
            if (grabbedObject && grabConstraint) {
                world.removeConstraint(grabConstraint); grabConstraint = null;
                grabbedObject.velocity.set(controllerVelocity.x * 1.5, controllerVelocity.y * 1.5, controllerVelocity.z * 1.5);
                grabbedObject = null;
            }
        });

        // --- オブジェクト生成 ---
        function spawnObject(position, direction) {
            if (!position) {
                direction = new THREE.Vector3(); camera.getWorldDirection(direction);
                position = new THREE.Vector3().copy(dolly.position).add(new THREE.Vector3(0, 2, 0)).add(direction.clone().multiplyScalar(1));
            }
            const spawnPos = position.clone().add(direction ? direction.multiplyScalar(0.5) : new THREE.Vector3());
            const size = Math.random() * 1.5 + 0.3;
            const r = Math.random(); let geo, shape;
            if (r < 0.4) { geo = new THREE.BoxGeometry(size, size, size); shape = new CANNON.Box(new CANNON.Vec3(size/2, size/2, size/2)); } 
            else if (r < 0.7) { geo = new THREE.SphereGeometry(size/2); shape = new CANNON.Sphere(size/2); } 
            else { geo = new THREE.CylinderGeometry(size/2, size/2, size); shape = new CANNON.Cylinder(size/2, size/2, size); }
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.7 }));
            mesh.position.copy(spawnPos); mesh.castShadow = true; scene.add(mesh);
            const body = new CANNON.Body({ mass: size * 10, shape: shape, material: physicsMat });
            body.position.copy(spawnPos); body.quaternion.setFromAxisAngle(new CANNON.Vec3(Math.random(), Math.random(), Math.random()).unit(), Math.random() * Math.PI);
            world.addBody(body); objects.push({ mesh, body });
            if (objects.length > maxObjects) { const old = objects.shift(); scene.remove(old.mesh); world.removeBody(old.body); }
        }

        // --- UI Events ---
        const uiContainer = document.getElementById('ui-container');
        const vrInstructions = document.getElementById('vr-instructions');
        const jumpBtn = document.getElementById('jump-btn');
        const spawnBtn = document.getElementById('spawn-btn');
        const alchemyBtn = document.getElementById('alchemy-btn');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const lookZone = document.getElementById('look-zone');

        renderer.xr.addEventListener('sessionstart', () => { isVR = true; uiContainer.querySelectorAll('.ui-element').forEach(el => el.style.display = 'none'); vrInstructions.style.display = 'block'; });
        renderer.xr.addEventListener('sessionend', () => { isVR = false; uiContainer.querySelectorAll('.ui-element').forEach(el => el.style.display = 'flex'); vrInstructions.style.display = 'none'; });

        spawnBtn.addEventListener('click', () => spawnObject()); spawnBtn.addEventListener('touchstart', (e) => { e.preventDefault(); spawnObject(); }, { passive: false });
        const doJump = () => { if (canJump) { playerBody.applyImpulse(new CANNON.Vec3(0, jumpImpulse, 0), playerBody.position); canJump = false; } };
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); doJump(); }, { passive: false });
        
        // スマホ用錬金術ボタン
        const doAlchemyMobile = () => { 
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            const pos = new THREE.Vector3().copy(dolly.position).add(dir.multiplyScalar(3)); // 3m前に出す
            pos.y = 0; performAlchemy(pos);
        };
        alchemyBtn.addEventListener('touchstart', (e) => { e.preventDefault(); doAlchemyMobile(); }, { passive: false });

        let joyId = null, joyCenter = { x: 0, y: 0 };
        joystickZone.addEventListener('touchstart', (e) => { e.preventDefault(); const t = e.changedTouches[0]; joyId = t.identifier; const rect = joystickZone.getBoundingClientRect(); joyCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }; moveJoy(t.clientX, t.clientY); }, { passive: false });
        joystickZone.addEventListener('touchmove', (e) => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joyId) moveJoy(e.changedTouches[i].clientX, e.changedTouches[i].clientY); } }, { passive: false });
        joystickZone.addEventListener('touchend', (e) => { e.preventDefault(); input.x = 0; input.y = 0; joystickKnob.style.transform = `translate(-50%, -50%)`; }, { passive: false });
        function moveJoy(x, y) { const maxR = 40; let dx = x - joyCenter.x; let dy = y - joyCenter.y; const dist = Math.sqrt(dx*dx + dy*dy); if(dist > maxR) { dx = (dx/dist)*maxR; dy = (dy/dist)*maxR; } joystickKnob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`; input.x = dx / maxR; input.y = dy / maxR; }

        let lastX, lastY;
        lookZone.addEventListener('touchstart', (e) => { lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; }, { passive: false });
        lookZone.addEventListener('touchmove', (e) => { e.preventDefault(); const x = e.touches[0].clientX; const y = e.touches[0].clientY; if (lastX != null) { cameraAngle.yaw -= (x - lastX) * 0.005; cameraAngle.pitch -= (y - lastY) * 0.005; cameraAngle.pitch = Math.max(-1.5, Math.min(1.5, cameraAngle.pitch)); } lastX = x; lastY = y; }, { passive: false });
        lookZone.addEventListener('touchend', () => { lastX = null; lastY = null; });

        // --- メインループ ---
        const clock = new THREE.Clock();
        let jumpButtonPressedPrev = false;

        renderer.setAnimationLoop(() => {
            const dt = Math.min(clock.getDelta(), 0.1);
            if(alchemyCooldown > 0) alchemyCooldown--;

            if (isVR) {
                controller2.getWorldPosition(controllerPosCurr);
                if (grabConstraint) handBody.position.copy(controllerPosCurr);
                controllerVelocity.subVectors(controllerPosCurr, controllerPosPrev).divideScalar(dt);
                controllerPosPrev.copy(controllerPosCurr);

                // --- 錬金術判定 (両手が地面にあるか) ---
                const p1 = controller1.getWorldPosition(new THREE.Vector3());
                const p2 = controller2.getWorldPosition(new THREE.Vector3());
                // 床(y=0)から0.2m以内なら発動
                if (p1.y < 0.2 && p2.y < 0.2) {
                    const centerPos = p1.clone().add(p2).multiplyScalar(0.5);
                    performAlchemy(centerPos);
                }
            }
            
            world.step(timeStep, dt, 5);
            if (playerBody.position.y <= playerRadius + 0.15) canJump = true;

            if (isVR) {
                // VR Inputs
                let vrMoveX = 0, vrMoveZ = 0, vrRotX = 0;
                let jumpButtonPressed = false;
                const session = renderer.xr.getSession();
                if (session && session.inputSources) {
                    for (const source of session.inputSources) {
                        if (!source.gamepad) continue;
                        if (source.handedness === 'left') { // Move
                            const axes = source.gamepad.axes; if (axes.length >= 4) { vrMoveX = axes[2]; vrMoveZ = axes[3]; }
                        }
                        if (source.handedness === 'right') { // Rotate & Jump
                            const axes = source.gamepad.axes; if (axes.length >= 4) { vrRotX = axes[2]; }
                            const btns = source.gamepad.buttons; if ((btns[4] && btns[4].pressed) || (btns[3] && btns[3].pressed)) { jumpButtonPressed = true; }
                        }
                    }
                }

                if (jumpButtonPressed && !jumpButtonPressedPrev) doJump();
                jumpButtonPressedPrev = jumpButtonPressed;

                // 右スティックで回転
                if (Math.abs(vrRotX) > 0.1) {
                    dolly.rotation.y -= vrRotX * turnSpeed * dt;
                }

                // 左スティックで移動 (dollyの向き基準)
                if (Math.abs(vrMoveX) > 0.1 || Math.abs(vrMoveZ) > 0.1) {
                    const headRotY = dolly.rotation.y + new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ').y; // dolly + head rotation
                    // ※dollyを回しているので、camera.quaternionだけで計算するとずれる場合があるが、
                    // WebXRのcameraはdollyの子なので、ワールド方向を取得して計算
                    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
                    const right = new THREE.Vector3(); right.crossVectors(camera.up, forward).negate(); // cross logic adjustment

                    const moveVec = right.clone().multiplyScalar(vrMoveX).add(forward.clone().multiplyScalar(vrMoveZ)).normalize().multiplyScalar(moveSpeed);
                    playerBody.velocity.x = moveVec.x * 0.8 + playerBody.velocity.x * 0.2;
                    playerBody.velocity.z = moveVec.z * 0.8 + playerBody.velocity.z * 0.2;
                } else {
                    playerBody.velocity.x *= 0.9; playerBody.velocity.z *= 0.9;
                }
            } else {
                // Mobile
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.yaw);
                const moveVec = new THREE.Vector3().addScaledVector(right, input.x).addScaledVector(forward, -input.y).normalize().multiplyScalar(moveSpeed);
                playerBody.velocity.x = moveVec.x; playerBody.velocity.z = moveVec.z;
                camera.rotation.set(cameraAngle.pitch, cameraAngle.yaw, 0, 'YXZ');
            }
            
            dolly.position.copy(playerBody.position);
            dolly.position.y -= playerRadius; dolly.position.y += eyeHeightOffset;

            for (const obj of objects) { obj.mesh.position.copy(obj.body.position); obj.mesh.quaternion.copy(obj.body.quaternion); }
            renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
