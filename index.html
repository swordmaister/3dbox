<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Physics Sandbox - Fixed Height</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .ui-element { pointer-events: auto; z-index: 20; user-select: none; display: flex; justify-content: center; align-items: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); border: 3px solid white; }
        #spawn-btn { position: absolute; right: 20px; bottom: 80px; width: 80px; height: 80px; background: #2196F3; color: white; border-radius: 50%; font-weight: bold; font-size: 14px; }
        #spawn-btn:active { transform: scale(0.9); background: #1976D2; }
        #jump-btn { position: absolute; left: 160px; bottom: 100px; width: 80px; height: 40px; background: #ff9800; color: white; border-radius: 8px; font-weight: bold; font-size: 14px; }
        #jump-btn:active { transform: scale(0.9); background: #e68900; }
        #joystick-zone { position: absolute; left: 20px; bottom: 40px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; border: none; box-shadow: none; }
        #look-zone { position: absolute; top: 0; right: 0; bottom: 0; left: 40%; pointer-events: auto; z-index: 9; }
        #vr-instructions { position: absolute; top: 20%; width: 100%; text-align: center; color: white; font-size: 1.2em; text-shadow: 1px 1px 2px black; pointer-events: none; display: none; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="look-zone"></div>
        <div id="joystick-zone" class="ui-element"><div id="joystick-knob"></div></div>
        <div id="jump-btn" class="ui-element">JUMP</div>
        <div id="spawn-btn" class="ui-element">DROP</div>
        <div id="vr-instructions">
            <p>左スティック: 移動</p>
            <p>右Aボタン: ジャンプ</p>
            <p>右トリガー: 掴む / 投げる</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // --- 設定 ---
        const timeStep = 1 / 60;
        const objects = [];
        const input = { x: 0, y: 0 };
        const cameraAngle = { pitch: 0, yaw: 0 };
        const maxObjects = 200;
        let isVR = false;

        // ★ 視点の高さ補正 (メートル)
        // 物理ボディ(足元)からどれくらい上にカメラを置くか
        const eyeHeightOffset = 1.3; 

        // --- 物理エンジン ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.solver.iterations = 10;
        const physicsMat = new CANNON.Material();
        const contactMat = new CANNON.ContactMaterial(physicsMat, physicsMat, { friction: 0.4, restitution: 0.3 });
        world.addContactMaterial(contactMat);

        const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: physicsMat });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);
        
        // プレイヤーの足元 (球体)
        const playerHeight = 1.7;
        const playerRadius = 0.3;
        const playerBody = new CANNON.Body({ mass: 80, shape: new CANNON.Sphere(playerRadius), material: physicsMat, fixedRotation: true, linearDamping: 0.95 });
        playerBody.position.set(0, 5, 0); // 最初は上空から
        world.addBody(playerBody);

        let canJump = true;
        const jumpImpulse = 400;
        const moveSpeed = 6.0;

        // --- グラフィックス ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccee);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const dolly = new THREE.Group();
        scene.add(dolly);
        dolly.add(camera);
        // 初期位置
        dolly.position.set(0, playerHeight, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        // ローカルフロア (床基準) を設定
        renderer.xr.setReferenceSpaceType('local-floor');
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 30; dirLight.shadow.camera.bottom = -30; dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30;
        scene.add(dirLight);

        const groundMesh = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 }) );
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // 壁の生成
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
        const wallPhysMat = new CANNON.Material({friction: 0.1, restitution: 0});
        const halfExtent = 25; const wallHeight = 5; const wallThickness = 1.0;
        const createWall = (x, z, w, d) => {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, wallHeight*2, d), wallMat);
            mesh.position.set(x, wallHeight, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(w/2, wallHeight, d/2)), material: wallPhysMat });
            body.position.set(x, wallHeight, z);
            world.addBody(body);
        };
        createWall(halfExtent, 0, wallThickness, halfExtent*2 + wallThickness*2);
        createWall(-halfExtent, 0, wallThickness, halfExtent*2 + wallThickness*2);
        createWall(0, halfExtent, halfExtent*2, wallThickness);
        createWall(0, -halfExtent, halfExtent*2, wallThickness);

        // --- VRコントローラー ---
        const controller1 = renderer.xr.getController(0);
        const controller2 = renderer.xr.getController(1);
        dolly.add(controller1);
        dolly.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();
        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        dolly.add(controllerGrip1);
        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        dolly.add(controllerGrip2);

        // 掴む機能
        let grabbedObject = null;
        let grabConstraint = null;
        const grabDistance = 1.0; // 少し遠くても吸い寄せる
        
        const handBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
        handBody.collisionFilterGroup = 0;
        handBody.collisionFilterMask = 0;
        world.addBody(handBody);

        const controllerPosPrev = new THREE.Vector3();
        const controllerPosCurr = new THREE.Vector3();
        const controllerVelocity = new THREE.Vector3();

        controller2.addEventListener('selectstart', onGrabStart);
        controller2.addEventListener('selectend', onGrabEnd);

        function onGrabStart() {
            if (grabbedObject) return;
            const controllerPos = controller2.getWorldPosition(new THREE.Vector3());
            let closestDist = grabDistance;
            let targetBody = null;
            for (const obj of objects) {
                const dist = controllerPos.distanceTo(obj.mesh.position);
                if (dist < closestDist) { closestDist = dist; targetBody = obj.body; }
            }
            if (targetBody) {
                grabbedObject = targetBody;
                handBody.position.copy(controllerPos);
                grabConstraint = new CANNON.PointToPointConstraint(handBody, new CANNON.Vec3(0, 0, 0), grabbedObject, new CANNON.Vec3(0, 0, 0));
                world.addConstraint(grabConstraint);
            }
        }

        function onGrabEnd() {
            if (grabbedObject && grabConstraint) {
                world.removeConstraint(grabConstraint);
                grabConstraint = null;
                grabbedObject.velocity.set(controllerVelocity.x * 1.5, controllerVelocity.y * 1.5, controllerVelocity.z * 1.5); // 投げる力を増強
                grabbedObject.angularVelocity.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).scale(5);
                grabbedObject = null;
            }
        }

        // --- ロジック ---
        function spawnObject(position, direction) {
            if (!position) {
                direction = new THREE.Vector3(); camera.getWorldDirection(direction);
                position = new THREE.Vector3().copy(dolly.position).add(new THREE.Vector3(0, 2, 0)).add(direction.clone().multiplyScalar(1));
            }
            const spawnPos = position.clone();
            if(direction) spawnPos.add(direction.multiplyScalar(0.5));

            const size = Math.random() * 1.5 + 0.3;
            const r = Math.random();
            let geo, shape;
            if (r < 0.4) { geo = new THREE.BoxGeometry(size, size, size); shape = new CANNON.Box(new CANNON.Vec3(size/2, size/2, size/2)); } 
            else if (r < 0.7) { geo = new THREE.SphereGeometry(size/2); shape = new CANNON.Sphere(size/2); } 
            else { geo = new THREE.CylinderGeometry(size/2, size/2, size); shape = new CANNON.Cylinder(size/2, size/2, size); }

            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.7 }));
            mesh.position.copy(spawnPos);
            mesh.castShadow = true; scene.add(mesh);

            const body = new CANNON.Body({ mass: size * 10, shape: shape, material: physicsMat });
            body.position.copy(spawnPos);
            body.quaternion.setFromAxisAngle(new CANNON.Vec3(Math.random(), Math.random(), Math.random()).unit(), Math.random() * Math.PI);
            world.addBody(body);
            objects.push({ mesh, body });
            if (objects.length > maxObjects) { const old = objects.shift(); scene.remove(old.mesh); world.removeBody(old.body); }
        }

        // --- 操作イベント (Mobile) ---
        const uiContainer = document.getElementById('ui-container');
        const vrInstructions = document.getElementById('vr-instructions');
        const jumpBtn = document.getElementById('jump-btn');
        const spawnBtn = document.getElementById('spawn-btn');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const lookZone = document.getElementById('look-zone');

        renderer.xr.addEventListener('sessionstart', () => { 
            isVR = true; 
            uiContainer.querySelectorAll('.ui-element').forEach(el => el.style.display = 'none');
            vrInstructions.style.display = 'block';
        });
        renderer.xr.addEventListener('sessionend', () => { 
            isVR = false; 
            uiContainer.querySelectorAll('.ui-element').forEach(el => el.style.display = 'flex');
            vrInstructions.style.display = 'none';
        });

        spawnBtn.addEventListener('touchstart', (e) => { e.preventDefault(); spawnObject(); }, { passive: false });
        spawnBtn.addEventListener('click', (e) => { spawnObject(); });
        
        const doJump = () => {
            if (canJump) {
                playerBody.applyImpulse(new CANNON.Vec3(0, jumpImpulse, 0), playerBody.position);
                canJump = false;
            }
        };
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); doJump(); }, { passive: false });

        let joyId = null, joyCenter = { x: 0, y: 0 };
        joystickZone.addEventListener('touchstart', (e) => { e.preventDefault(); const t = e.changedTouches[0]; joyId = t.identifier; const rect = joystickZone.getBoundingClientRect(); joyCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }; moveJoy(t.clientX, t.clientY); }, { passive: false });
        joystickZone.addEventListener('touchmove', (e) => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joyId) moveJoy(e.changedTouches[i].clientX, e.changedTouches[i].clientY); } }, { passive: false });
        joystickZone.addEventListener('touchend', (e) => { e.preventDefault(); input.x = 0; input.y = 0; joystickKnob.style.transform = `translate(-50%, -50%)`; }, { passive: false });
        function moveJoy(x, y) { const maxR = 40; let dx = x - joyCenter.x; let dy = y - joyCenter.y; const dist = Math.sqrt(dx*dx + dy*dy); if(dist > maxR) { dx = (dx/dist)*maxR; dy = (dy/dist)*maxR; } joystickKnob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`; input.x = dx / maxR; input.y = dy / maxR; }

        let lastX, lastY;
        lookZone.addEventListener('touchstart', (e) => { lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; }, { passive: false });
        lookZone.addEventListener('touchmove', (e) => { e.preventDefault(); const x = e.touches[0].clientX; const y = e.touches[0].clientY; if (lastX != null) { cameraAngle.yaw -= (x - lastX) * 0.005; cameraAngle.pitch -= (y - lastY) * 0.005; cameraAngle.pitch = Math.max(-1.5, Math.min(1.5, cameraAngle.pitch)); } lastX = x; lastY = y; }, { passive: false });
        lookZone.addEventListener('touchend', () => { lastX = null; lastY = null; });

        // --- メインループ ---
        const clock = new THREE.Clock();
        let jumpButtonPressedPrev = false;

        renderer.setAnimationLoop(() => {
            const dt = Math.min(clock.getDelta(), 0.1);
            
            if (isVR) {
                controller2.getWorldPosition(controllerPosCurr);
                if (grabConstraint) { handBody.position.copy(controllerPosCurr); }
                controllerVelocity.subVectors(controllerPosCurr, controllerPosPrev).divideScalar(dt);
                controllerPosPrev.copy(controllerPosCurr);
            }
            
            world.step(timeStep, dt, 5);

            if (playerBody.position.y <= playerRadius + 0.15) canJump = true;

            if (isVR) {
                // VRモード
                let vrMoveX = 0, vrMoveZ = 0;
                let jumpButtonPressed = false;
                const session = renderer.xr.getSession();
                if (session && session.inputSources) {
                    for (const source of session.inputSources) {
                        if (!source.gamepad) continue;
                        if (source.handedness === 'left') {
                            const axes = source.gamepad.axes;
                            if (axes.length >= 4) { vrMoveX = axes[2]; vrMoveZ = axes[3]; }
                        }
                        if (source.handedness === 'right') {
                            const btns = source.gamepad.buttons;
                            if ((btns[4] && btns[4].pressed) || (btns[3] && btns[3].pressed)) { jumpButtonPressed = true; }
                        }
                    }
                }

                if (jumpButtonPressed && !jumpButtonPressedPrev) doJump();
                jumpButtonPressedPrev = jumpButtonPressed;

                const headRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                if (Math.abs(vrMoveX) > 0.1 || Math.abs(vrMoveZ) > 0.1) {
                    const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), headRotation.y);
                    const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), headRotation.y);
                    const moveVec = new THREE.Vector3().addScaledVector(right, vrMoveX).addScaledVector(forward, vrMoveZ).normalize().multiplyScalar(moveSpeed);
                    playerBody.velocity.x = moveVec.x * 0.8 + playerBody.velocity.x * 0.2;
                    playerBody.velocity.z = moveVec.z * 0.8 + playerBody.velocity.z * 0.2;
                } else {
                    playerBody.velocity.x *= 0.9; playerBody.velocity.z *= 0.9;
                }

            } else {
                // Mobileモード
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.yaw);
                const moveVec = new THREE.Vector3().addScaledVector(right, input.x).addScaledVector(forward, -input.y).normalize().multiplyScalar(moveSpeed);
                playerBody.velocity.x = moveVec.x; playerBody.velocity.z = moveVec.z;
                camera.rotation.set(cameraAngle.pitch, cameraAngle.yaw, 0, 'YXZ');
            }
            
            // ★ カメラ位置の更新 (高さ補正を追加) ★
            dolly.position.copy(playerBody.position);
            dolly.position.y -= playerRadius; // 足元基準にする
            dolly.position.y += eyeHeightOffset; // ここで高さを盛る (1.3mアップ)

            for (const obj of objects) {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }
            renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
