<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Mobile VR Dev Kit</title>
<style>
    /* --- 基本スタイル --- */
    :root {
        --bg-color: #1e1e1e;
        --editor-bg: #2d2d2d;
        --text-color: #e0e0e0;
        --accent-color: #007acc;
        --danger-color: #d9534f;
    }
    body {
        margin: 0; padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: monospace;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    button, select {
        font-family: sans-serif;
        touch-action: manipulation;
    }

    /* --- 1. エディタ画面 UI --- */
    #editor-screen {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 10px;
        box-sizing: border-box;
    }
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
        align-items: center;
    }
    .toolbar-group {
        display: flex;
        gap: 4px;
        background: #333;
        padding: 4px;
        border-radius: 6px;
    }
    select {
        background: #444; color: #fff; border: 1px solid #555;
        padding: 8px; border-radius: 4px; font-size: 14px;
    }
    .btn {
        background: #444; color: #fff; border: none;
        padding: 8px 12px; border-radius: 4px; font-size: 13px; cursor: pointer;
    }
    .btn:active { background: #666; }
    .btn-primary { background: var(--accent-color); font-weight: bold; }
    .btn-danger { background: var(--danger-color); }
    
    #code-area {
        flex-grow: 1;
        background-color: var(--editor-bg);
        color: #fff;
        border: 1px solid #444;
        padding: 10px;
        font-size: 14px;
        resize: none;
        outline: none;
        border-radius: 4px;
        white-space: pre;
        overflow-x: auto;
    }

    #run-btn {
        margin-top: 10px;
        padding: 15px;
        font-size: 18px;
        background: #0a0;
        color: white;
        border: none;
        border-radius: 6px;
        width: 100%;
    }

    /* --- 2. VRエミュレータ画面 UI --- */
    #emulator-screen {
        display: none; /* 初期状態は非表示 */
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #000;
        z-index: 100;
    }
    
    /* 実行されるiframe */
    #vr-frame {
        width: 100%; height: 100%; border: none;
        display: block;
    }

    /* オーバーレイUI */
    #exit-btn {
        position: absolute;
        top: 10px; left: 10px;
        width: 40px; height: 40px;
        background: rgba(255, 0, 0, 0.7);
        color: white;
        border: 2px solid white;
        border-radius: 50%;
        font-size: 24px;
        line-height: 36px;
        text-align: center;
        z-index: 200;
        cursor: pointer;
    }
    
    #controls-overlay {
        position: absolute;
        bottom: 0; left: 0; width: 100%; height: 40%;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        padding: 20px;
        box-sizing: border-box;
        /* pointer-events: none; は不要。UI操作はオーバーレイが受け持つ */
    }

    /* コントローラーパーツ */
    .control-zone {
        pointer-events: auto;
        background: rgba(50, 50, 50, 0.5);
        border-radius: 20px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }

    .v-btn {
        width: 50px; height: 50px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        color: white;
        font-weight: bold;
        display: flex; justify-content: center; align-items: center;
        user-select: none;
    }
    .v-btn:active { background: rgba(0, 255, 0, 0.5); border-color: #0f0; }

    #joystick-area {
        width: 120px; height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        position: relative;
        touch-action: none;
    }
    #joystick-knob {
        width: 50px; height: 50px;
        background: rgba(0, 150, 255, 0.8);
        border-radius: 50%;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }
    
    #gyro-status {
        position: absolute; top: 10px; right: 10px;
        color: lime; font-size: 12px;
        background: rgba(0,0,0,0.5); padding: 4px;
    }
</style>
</head>
<body>

    <div id="editor-screen">
        <div class="toolbar">
            <div class="toolbar-group">
                <select id="slot-select">
                    <option value="1">Slot 1</option>
                    <option value="2">Slot 2</option>
                    <option value="3">Slot 3</option>
                    <option value="4">Slot 4</option>
                    <option value="5">Slot 5</option>
                </select>
                <button class="btn" onclick="saveSlot()">保存</button>
                <button class="btn" onclick="loadSlot()">読込</button>
            </div>
            <div class="toolbar-group">
                <button class="btn" onclick="copyCode()">コピー</button>
                <button class="btn" onclick="pasteCode()">ペースト</button>
                <button class="btn btn-danger" onclick="clearCode()">クリア</button>
            </div>
        </div>
        
        <textarea id="code-area" spellcheck="false" placeholder="ここにWebXR対応のHTMLコードを貼り付けてください..."></textarea>
        
        <button id="run-btn" onclick="runVR()">VRモード起動 (RUN)</button>
    </div>

    <div id="emulator-screen">
        <div id="exit-btn" onclick="exitVR()">×</div>
        <div id="gyro-status">Gyro: Ready</div>
        
        <iframe id="vr-frame"></iframe>

        <div id="controls-overlay">
            <div class="control-zone">
                <div id="joystick-area">
                    <div id="joystick-knob"></div>
                </div>
                <span style="color:#aaa; font-size:10px">MOVE</span>
            </div>
            
            <div class="control-zone">
                <div style="display:flex; gap:10px;">
                    <div class="v-btn" data-key="trigger">Trig</div>
                    <div class="v-btn" data-key="grip">Grip</div>
                </div>
                <div style="display:flex; gap:10px;">
                    <div class="v-btn" data-key="A">A</div>
                    <div class="v-btn" data-key="B">B</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === 1. WebXR Mock Library (Iframe内に注入されるコード) ===
        // Iframe内で実行されることで、親ウィンドウのコードとの競合を防ぎます。
        const MOCK_LIB_CODE = `
        <script>
        (function() {
            console.log("WebXR Emulator Mock Initialized inside Iframe");
            
            // 内部状態
            const state = {
                position: [0, 1.6, 0],
                quaternion: [0, 0, 0, 1],
                inputs: {
                    left: { axes: [0,0], buttons: {} },
                    right: { axes: [0,0], buttons: {} }
                }
            };

            // 親ウィンドウからのメッセージ受信リスナー
            window.addEventListener('message', (e) => {
                const msg = e.data;
                // メッセージがこのエミュレーター用か確認
                if (!msg || !msg.type || msg.source !== 'VR_HOST') return; 

                if (msg.type === 'updateInput') {
                    if(msg.hand === 'left') {
                        if(msg.axes) state.inputs.left.axes = msg.axes;
                    }
                    if(msg.hand === 'right') {
                        Object.assign(state.inputs.right.buttons, msg.buttons);
                    }
                }
                else if (msg.type === 'updatePose') {
                    if(msg.position) state.position = msg.position;
                    if(msg.quaternion) state.quaternion = msg.quaternion;
                }
            });

            // --- WebXR API Mock Class Definitions ---
            
            class MockXRSession {
                constructor() {
                    this.ended = false;
                    this.inputSources = [
                        this._createInputSource('left'),
                        this._createInputSource('right')
                    ];
                    this.renderState = { baseLayer: null };
                    this.viewerSpace = { name: 'viewer' };
                }

                _createInputSource(hand) {
                    return {
                        handedness: hand,
                        targetRayMode: 'tracked-pointer',
                        profiles: ['oculus-touch'],
                        gamepad: {
                            buttons: [
                                { pressed: false, value: 0 }, // Trigger
                                { pressed: false, value: 0 }, // Grip
                                { pressed: false, value: 0 }, // Pad
                                { pressed: false, value: 0 }, // Thumbstick
                                { pressed: false, value: 0 }, // A/X
                                { pressed: false, value: 0 }, // B/Y
                            ],
                            axes: [0, 0]
                        }
                    };
                }

                _updateInputSources() {
                    const mapBtn = (btnState) => ({ pressed: !!btnState, value: btnState ? 1 : 0 });
                    
                    // Left (Joystick for movement)
                    this.inputSources[0].gamepad.axes = state.inputs.left.axes;
                    
                    // Right (Buttons)
                    const rBtns = state.inputs.right.buttons;
                    const gp = this.inputSources[1].gamepad.buttons;
                    gp[0] = mapBtn(rBtns.trigger);
                    gp[1] = mapBtn(rBtns.grip);
                    gp[4] = mapBtn(rBtns.A);
                    gp[5] = mapBtn(rBtns.B);
                }

                requestReferenceSpace(type) {
                    // XRSessionを返す
                    return Promise.resolve(this.viewerSpace);
                }
                
                getViewerPose(refSpace) {
                     this._updateInputSources();
                     
                     // Iframeのサイズをビューポートとして利用
                     const width = window.innerWidth;
                     const height = window.innerHeight;
                     
                     return {
                        transform: {
                            // 姿勢
                            position: { x: state.position[0], y: state.position[1], z: state.position[2], w: 1 },
                            orientation: { x: state.quaternion[0], y: state.quaternion[1], z: state.quaternion[2], w: state.quaternion[3] }
                        },
                        views: [{
                            eye: 'left', // Monoscopic
                            projectionMatrix: [1.2, 0, 0, 0, 0, 2.4, 0, 0, 0, 0, -1, -1, 0, 0, -0.2, 0], // Dummy Projection
                            transform: { position: {x:0,y:0,z:0}, orientation: {x:0,y:0,z:0,w:1} },
                            viewport: { x: 0, y: 0, width: width, height: height }
                        }]
                    };
                }
                
                getPose(inputSource, refSpace) {
                    // コントローラーの位置は常に固定 (HMDを基準)
                    return {
                        transform: {
                            position: { x: inputSource.handedness === 'left' ? -0.2 : 0.2, y: 1.4, z: -0.5, w: 1 },
                            orientation: { x: 0, y: 0, z: 0, w: 1 }
                        }
                    };
                }

                updateRenderState(params) { 
                    if(params.baseLayer) this.renderState.baseLayer = params.baseLayer;
                }

                requestAnimationFrame(callback) {
                    if (this.ended) return 0;
                    return window.requestAnimationFrame((t) => {
                        callback(t, { 
                            session: this, 
                            getViewerPose: (refSpace) => this.getViewerPose(refSpace),
                            getPose: (inputSource, refSpace) => this.getPose(inputSource, refSpace)
                        });
                    });
                }
                
                end() { this.ended = true; return Promise.resolve(); }
                addEventListener() {}
                removeEventListener() {}
            }

            // Navigator Override
            const mockXR = {
                isSessionSupported: (mode) => Promise.resolve(mode === 'immersive-vr'),
                requestSession: (mode) => {
                    if (mode !== 'immersive-vr') return Promise.reject(new Error('Only immersive-vr mode is mocked.'));
                    return Promise.resolve(new MockXRSession());
                }
            };

            // window.navigator.xr を上書き
            try {
                Object.defineProperty(navigator, 'xr', { value: mockXR, configurable: true, writable: true });
            } catch(e) {
                window.navigator.xr = mockXR;
            }
            
        })();
        <\/script>
        `;

        // === 2. Editor & System Logic (ホスト/親ウィンドウ) ===

        const codeArea = document.getElementById('code-area');
        const slotSelect = document.getElementById('slot-select');
        const editorScreen = document.getElementById('editor-screen');
        const emulatorScreen = document.getElementById('emulator-screen');
        const vrFrame = document.getElementById('vr-frame');
        
        // デフォルトのサンプルコード（Three.js）
        const DEFAULT_CODE = `<!DOCTYPE html>
<html>
<head>
  <style>body { margin: 0; background: #000; }</style>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';

    // シーン設定
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; // WebXR有効化
    document.body.appendChild(renderer.domElement);

    // オブジェクト作成
    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(0, 1.6, -1);
    scene.add(cube);
    
    // ライト
    const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
    scene.add( light );

    // アニメーションループ
    renderer.setAnimationLoop(() => {
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
        renderer.render(scene, camera);
    });

    // VRセッション自動開始 (エミュレーター用)
    const startVR = async () => {
      if (navigator.xr) {
        try {
          const session = await navigator.xr.requestSession('immersive-vr');
          renderer.xr.setSession(session);
        } catch (e) { console.error("XR Start failed", e); }
      }
    };
    // 描画が安定してからセッションをリクエスト
    setTimeout(startVR, 100); 

  <\/script>
</head>
<body></body>
</html>`;

        // --- LocalStorage/Clipboard Functions ---
        window.onload = () => {
            loadSlot();
            if(!codeArea.value) codeArea.value = DEFAULT_CODE;
        };

        function saveSlot() {
            const slot = slotSelect.value;
            localStorage.setItem(`vr_emu_slot_${slot}`, codeArea.value);
            alert(`Slot ${slot} に保存しました`);
        }

        function loadSlot() {
            const slot = slotSelect.value;
            const data = localStorage.getItem(`vr_emu_slot_${slot}`);
            if (data) codeArea.value = data;
        }

        function clearCode() {
            if(confirm('エディタをクリアしますか？')) codeArea.value = '';
        }

        async function copyCode() {
            try {
                await navigator.clipboard.writeText(codeArea.value);
                alert('コピーしました');
            } catch (err) { alert('コピー失敗: ' + err); }
        }

        async function pasteCode() {
            try {
                const text = await navigator.clipboard.readText();
                codeArea.value = text;
            } catch (err) { alert('ペースト失敗: ' + err); }
        }
        
        // --- Run & Emulator Logic ---

        let pose = { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 };
        let initialGyroAlpha = null;
        let animationFrameId;

        // Iframeへメッセージを送信するヘルパー関数
        const postMessageToIframe = (message) => {
            if (vrFrame.contentWindow) {
                // Iframe内のコードが識別できるように 'VR_HOST' を送信元として追加
                vrFrame.contentWindow.postMessage(Object.assign(message, { source: 'VR_HOST' }), '*');
            }
        };

        async function runVR() {
            // ジャイロセンサーの許可リクエスト
            let gyroGranted = true;
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const state = await DeviceOrientationEvent.requestPermission();
                    if (state !== 'granted') gyroGranted = false;
                } catch(e) {
                    console.error("Gyro Permission Error:", e);
                    gyroGranted = false;
                }
            }
            
            startEmulator(gyroGranted);
        }

        function startEmulator(gyroGranted) {
            // UI切り替え
            editorScreen.style.display = 'none';
            emulatorScreen.style.display = 'block';
            
            // Iframe生成（WebXR Mock + ユーザーコード）
            // Iframe内でWebXRのモックが先に実行されるように、<head>タグの直後に注入
            const userCode = codeArea.value;
            const finalHtml = userCode.replace('<head>', '<head>' + MOCK_LIB_CODE);
            
            vrFrame.srcdoc = finalHtml;

            if (gyroGranted) {
                window.addEventListener('deviceorientation', handleOrientation);
                document.getElementById('gyro-status').textContent = 'Gyro: ON (Active)';
            } else {
                document.getElementById('gyro-status').textContent = 'Gyro: OFF (Touch Tracking)';
            }

            // ループ開始
            startLoop();
        }

        function exitVR() {
            emulatorScreen.style.display = 'none';
            editorScreen.style.display = 'flex';
            vrFrame.srcdoc = ''; // Reset iframe content
            window.removeEventListener('deviceorientation', handleOrientation);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            // Pose Reset
            pose = { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 }; 
            initialGyroAlpha = null;
        }

        // --- Orientation & Tracking ---

        function handleOrientation(e) {
            if(!initialGyroAlpha && e.alpha !== null) initialGyroAlpha = e.alpha;
            
            if(e.alpha !== null) {
                // Alpha (Z軸/Yaw) の初期値からの変化を計算
                const radA = (e.alpha - initialGyroAlpha) * (Math.PI / 180);
                // Beta (X軸/Pitch) - 90度を補正して、デバイス縦持ちを基準にする
                const radB = (e.beta !== null ? e.beta - 90 : 0) * (Math.PI / 180);
                
                pose.yaw = -radA; // 左回転でYaw+になるように調整
                pose.pitch = radB;
            }
        }
        
        // Touch Tracking (ジャイロがOFFの時の代替)
        let startX, startY, touchDrag;
        const ROTATION_FACTOR = 0.005; // 感度調整
        
        emulatorScreen.addEventListener('touchstart', (e) => {
            // コントロールUI外でのタッチのみ反応
            if (e.target.closest('#controls-overlay')) return; 
            touchDrag = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            e.preventDefault();
        });

        emulatorScreen.addEventListener('touchmove', (e) => {
            if(!touchDrag || e.target.closest('#controls-overlay')) return;
            e.preventDefault();
            
            if(document.getElementById('gyro-status').textContent.includes('Touch Tracking')) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;

                // YawとPitchを更新
                pose.yaw += deltaX * ROTATION_FACTOR;
                pose.pitch += deltaY * ROTATION_FACTOR;
                pose.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pose.pitch)); // 90度以上回らないようにクランプ

                startX = touch.clientX;
                startY = touch.clientY;
            }
        });
        emulatorScreen.addEventListener('touchend', () => { touchDrag = false; });


        // --- Input Handling (Joystick & Buttons) ---
        
        const joyZone = document.getElementById('joystick-area');
        const joyKnob = document.getElementById('joystick-knob');
        let joyDrag = false;
        let joyCenter = {x:0, y:0};
        
        // Joystick
        joyZone.addEventListener('touchstart', e => {
            joyDrag = true;
            const rect = joyZone.getBoundingClientRect();
            joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        }, {passive: false});

        joyZone.addEventListener('touchmove', e => {
            if(!joyDrag) return;
            e.preventDefault();
            const t = e.touches[0];
            const maxR = 35;
            let dx = t.clientX - joyCenter.x;
            let dy = t.clientY - joyCenter.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist > maxR) {
                dx = dx * (maxR/dist);
                dy = dy * (maxR/dist);
            }
            
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            
            const ax = dx / maxR; // X軸 (-1 to 1)
            const ay = dy / maxR; // Y軸 (-1 to 1)
            
            // 移動 (現在のYawに基づいて移動方向を計算)
            const speed = 0.05;
            const forward = -ay * speed; // Y軸マイナスが前進
            const sideways = ax * speed; 
            
            // Z軸(前後)とX軸(左右)の移動量を合成
            pose.x += Math.sin(pose.yaw) * forward + Math.cos(pose.yaw) * sideways;
            pose.z += Math.cos(pose.yaw) * forward - Math.sin(pose.yaw) * sideways;

            postMessageToIframe({ type: 'updateInput', hand: 'left', axes: [ax, ay] });
            
        }, {passive: false});

        const resetJoy = () => {
            joyDrag = false;
            joyKnob.style.transform = `translate(-50%, -50%)`;
            postMessageToIframe({ type: 'updateInput', hand: 'left', axes: [0, 0] });
        };
        joyZone.addEventListener('touchend', resetJoy);
        joyZone.addEventListener('touchcancel', resetJoy);

        // Buttons
        document.querySelectorAll('.v-btn').forEach(btn => {
            const key = btn.dataset.key;
            const send = (pressed) => {
                const msg = { type: 'updateInput', hand: 'right', buttons: {} };
                msg.buttons[key] = pressed;
                postMessageToIframe(msg);
            };
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); send(true); });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); send(false); });
        });

        // --- Main Loop (Pose Data Transmission) ---

        function startLoop() {
            function loop() {
                if(emulatorScreen.style.display === 'none') return;

                // Euler to Quaternion (Yaw-Pitch-Roll)
                const c1 = Math.cos(pose.yaw / 2);
                const s1 = Math.sin(pose.yaw / 2);
                const c2 = Math.cos(pose.pitch / 2);
                const s2 = Math.sin(pose.pitch / 2);
                const c3 = Math.cos(0); // Rollは0固定
                const s3 = Math.sin(0);

                // ZYX order (Y, P, R -> Q)
                const qw = c1 * c2 * c3 + s1 * s2 * s3; // w
                const qx = c1 * s2 * c3 + s1 * c2 * s3; // x
                const qy = s1 * c2 * c3 - c1 * s2 * s3; // y
                const qz = c1 * c2 * s3 - s1 * s2 * c3; // z

                postMessageToIframe({
                    type: 'updatePose',
                    position: [pose.x, pose.y, pose.z],
                    quaternion: [qx, qy, qz, qw]
                });

                animationFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

    </script>
</body>
</html>
