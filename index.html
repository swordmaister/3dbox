<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Quest 2 Emulator (Button Fix & 2D Track)</title>
<style>
    /* --- 全体レイアウト --- */
    :root {
        --bg-color: #000;
        --zone-bg: rgba(50, 50, 50, 0.5);
        --accent: #007acc;
        --knob-color: rgba(255, 255, 0, 0.7);
    }
    body {
        margin: 0; padding: 0; background-color: var(--bg-color); color: #eee;
        font-family: sans-serif; height: 100vh; overflow: hidden;
        display: flex; flex-direction: column;
    }
    button { touch-action: manipulation; }

    /* --- エディタ画面 --- */
    #editor-screen { display: flex; flex-direction: column; height: 100%; padding: 8px; box-sizing: border-box; background: #111; }
    .toolbar { display: flex; justify-content: space-between; margin-bottom: 8px; }
    .btn { background: #333; color: #fff; border: 1px solid #555; padding: 6px 10px; border-radius: 4px; font-size: 12px; }
    .btn-run { background: #2e7d32; width: 100%; padding: 12px; font-weight: bold; font-size: 16px; margin-top: 5px; color:white; border:none; border-radius:4px;}
    #code-area { flex-grow: 1; background: #1e1e1e; color: #f8f8f2; border: 1px solid #444; padding: 10px; font-family: monospace; resize: none; }

    /* --- エミュレータ画面 --- */
    #emulator-screen { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; }
    #vr-frame { width: 100%; height: 100%; border: none; display: block; }

    /* --- UIオーバーレイ --- */
    #ui-header {
        position: absolute; top: 0; left: 0; width: 100%; padding: 10px; box-sizing: border-box;
        display: flex; justify-content: space-between; pointer-events: none;
    }
    #exit-btn {
        pointer-events: auto; background: #d32f2f; color: white; width: 36px; height: 36px;
        border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; cursor: pointer; border: 2px solid #fff;
    }
    #status-display { background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; color: #0f0; font-size: 12px; }

    #controls-overlay {
        position: absolute; bottom: 0; left: 0; width: 100%; height: 48%;
        background: linear-gradient(to top, rgba(0,0,0,1) 40%, rgba(0,0,0,0));
        display: flex; justify-content: space-between; align-items: flex-end;
        padding: 5px; box-sizing: border-box; pointer-events: none;
    }

    .control-zone {
        pointer-events: auto; background: var(--zone-bg); border-radius: 12px;
        padding: 5px; display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
        width: 49%; height: 100%; border: 1px solid rgba(255,255,255,0.1); box-sizing: border-box;
        gap: 5px;
    }
    
    .label { font-size: 9px; color: #aaa; font-weight: bold; text-align: center; width: 100%; margin-bottom: 2px; }

    /* コンポーネント共通 */
    .row { display: flex; gap: 8px; justify-content: center; width: 100%; }

    /* ジョイスティック */
    .joy-container {
        width: 70px; height: 70px; background: rgba(255,255,255,0.1); border-radius: 50%;
        position: relative; touch-action: none; flex-shrink: 0;
    }
    .joy-stick {
        width: 30px; height: 30px; background: var(--accent); border-radius: 50%;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        box-shadow: 0 0 5px var(--accent); pointer-events: none;
    }

    /* ボタン */
    .vr-btn {
        width: 40px; height: 40px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3);
        border-radius: 50%; color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
        user-select: none; font-size: 10px; transition: background 0.1s;
    }
    .vr-btn:active { background: var(--accent); border-color: #fff; transform: scale(0.95); }
    
    /* トラッキングパッド (2D) */
    .pos-pad {
        width: 90%; height: 80px; /* 縦幅を広げて2D操作可能に */
        background: rgba(0,0,0,0.3); border: 1px dashed #666; border-radius: 6px;
        position: relative; touch-action: none;
    }
    .pos-knob {
        width: 20px; height: 20px; background: var(--knob-color); border-radius: 50%;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none;
        box-shadow: 0 0 5px yellow;
    }
    .pad-hint {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: rgba(255,255,255,0.2); font-size: 20px; pointer-events: none;
    }

</style>
</head>
<body>

    <div id="editor-screen">
        <div class="toolbar">
            <select id="slot-select">
                <option value="1">Slot 1</option><option value="2">Slot 2</option><option value="3">Slot 3</option>
            </select>
            <div>
                <button class="btn" onclick="app.io.save()">Save</button>
                <button class="btn" onclick="app.io.load()">Load</button>
                <button class="btn" onclick="app.io.paste()">Paste</button>
            </div>
        </div>
        <textarea id="code-area" spellcheck="false" placeholder="ここにWebXR対応HTMLを貼り付け"></textarea>
        <button class="btn-run" onclick="app.system.run()">▶ VR START</button>
    </div>

    <div id="emulator-screen">
        <div id="ui-header">
            <div id="exit-btn" onclick="app.system.exit()">×</div>
            <div id="status-display">Gyro: Waiting...</div>
        </div>
        
        <iframe id="vr-frame"></iframe>

        <div id="controls-overlay">
            <div class="control-zone">
                <div class="label">LEFT HAND</div>
                <div class="joy-container" id="joy-left"><div class="joy-stick" id="stick-left"></div></div>
                
                <div class="row">
                    <div class="vr-btn" data-hand="left" data-key="X">X</div>
                    <div class="vr-btn" data-hand="left" data-key="Y">Y</div>
                    <div class="vr-btn" data-hand="left" data-key="menu">M</div>
                </div>
                <div class="row">
                    <div class="vr-btn" data-hand="left" data-key="trigger">Trig</div>
                    <div class="vr-btn" data-hand="left" data-key="grip">Grip</div>
                </div>
                
                <div class="label">Position (X / Z)</div>
                <div class="pos-pad" id="pad-left">
                    <div class="pad-hint">+</div>
                    <div class="pos-knob" id="knob-left"></div>
                </div>
            </div>

            <div class="control-zone">
                <div class="label">RIGHT HAND</div>
                <div class="joy-container" id="joy-right"><div class="joy-stick" id="stick-right"></div></div>
                
                <div class="row">
                    <div class="vr-btn" data-hand="right" data-key="A">A</div>
                    <div class="vr-btn" data-hand="right" data-key="B">B</div>
                </div>
                <div class="row">
                    <div class="vr-btn" data-hand="right" data-key="trigger">Trig</div>
                    <div class="vr-btn" data-hand="right" data-key="grip">Grip</div>
                </div>

                <div class="label">Position (X / Z)</div>
                <div class="pos-pad" id="pad-right">
                    <div class="pad-hint">+</div>
                    <div class="pos-knob" id="knob-right"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === 1. Mock Library (注入用コード) ===
        const MOCK_LIB = `
        <script>
        (function() {
            console.log("[VR Mock] Logic v3 (Button Fix)...");
            
            // 内部状態
            const state = {
                viewer: { position: [0, 1.6, 0], quaternion: [0, 0, 0, 1] },
                inputs: {
                    left:  { axes: [0,0], buttons: {}, position: [-0.2, 1.4, -0.5], quaternion: [0,0,0,1], prevButtons: {} },
                    right: { axes: [0,0], buttons: {}, position: [ 0.2, 1.4, -0.5], quaternion: [0,0,0,1], prevButtons: {} }
                }
            };

            // Hostからのデータ受信
            window.addEventListener('message', (e) => {
                if (!e.data || e.data.source !== 'VR_HOST') return;
                const msg = e.data.payload;
                
                if (msg.type === 'pose') {
                    if (msg.viewer) state.viewer = msg.viewer;
                    ['left', 'right'].forEach(hand => {
                        if (msg[hand]) {
                            if(msg[hand].position) state.inputs[hand].position = msg[hand].position;
                            if(msg[hand].axes) state.inputs[hand].axes = msg[hand].axes;
                        }
                    });
                    if (msg.buttons) {
                        const target = state.inputs[msg.hand].buttons;
                        Object.assign(target, msg.buttons);
                    }
                }
            });

            // Mock Gamepad: オブジェクトを再利用し、値だけ書き換える
            class MockGamepad {
                constructor() {
                    this.buttons = Array(7).fill(0).map(() => ({ pressed: false, value: 0 }));
                    this.axes = [0, 0, 0, 0];
                    this.mapping = 'xr-standard';
                }
                
                update(data, hand) {
                    // Axes Update
                    if(data.axes) {
                        this.axes[2] = data.axes[0]; 
                        this.axes[3] = data.axes[1];
                    } else {
                        this.axes[2] = 0; this.axes[3] = 0;
                    }

                    // Buttons Update (In-Place)
                    const mapBtn = (b, i) => {
                        const val = !!b;
                        this.buttons[i].pressed = val;
                        this.buttons[i].value = val ? 1 : 0;
                    };
                    
                    // 0:Trig, 1:Grip, 2:Pad, 3:Stick, 4:A/X, 5:B/Y
                    mapBtn(data.buttons.trigger, 0);
                    mapBtn(data.buttons.grip, 1);
                    mapBtn(hand==='left' ? data.buttons.X : data.buttons.A, 4);
                    mapBtn(hand==='left' ? data.buttons.Y : data.buttons.B, 5);
                    mapBtn(data.buttons.menu, 6);
                }
            }

            // Mock InputSource
            class MockInputSource {
                constructor(hand) {
                    this.handedness = hand;
                    this.targetRayMode = 'tracked-pointer';
                    this.profiles = ['oculus-touch-v3', 'oculus-touch'];
                    this.gamepad = new MockGamepad();
                }
            }

            // Mock Session
            class MockXRSession extends EventTarget {
                constructor() {
                    super();
                    this.ended = false;
                    this.renderState = { baseLayer: null };
                    
                    // 永続的なInputSource配列
                    this._inputSources = [
                        new MockInputSource('left'),
                        new MockInputSource('right')
                    ];
                    
                    this._listeners = {};
                }

                get inputSources() { return this._inputSources; }

                // Event Polyfill
                addEventListener(type, cb) { 
                    if(!this._listeners[type]) this._listeners[type]=[]; 
                    this._listeners[type].push(cb); 
                }
                removeEventListener(type, cb) {
                    if(this._listeners[type]) this._listeners[type] = this._listeners[type].filter(c => c!==cb);
                }
                dispatchEvent(event) {
                    if(this._listeners[event.type]) this._listeners[event.type].forEach(cb => cb(event));
                }
                
                // イベント処理と状態同期
                _updateAndFireEvents(index) {
                    const src = this._inputSources[index];
                    const hand = src.handedness;
                    const curr = state.inputs[hand].buttons;
                    const prev = state.inputs[hand].prevButtons || {};
                    
                    // 1. まずGamepadの状態を最新にする
                    src.gamepad.update(state.inputs[hand], hand);

                    // 2. 状態変化に基づいてイベントを発火
                    const check = (key, typeStart, typeEnd) => {
                        const now = !!curr[key];
                        const old = !!prev[key];
                        if (now && !old) this.dispatchEvent({ type: typeStart, inputSource: src, frame: this._lastFrame });
                        if (!now && old) {
                            this.dispatchEvent({ type: typeEnd, inputSource: src, frame: this._lastFrame });
                            // select/squeezeはend時に発火
                            const shortType = typeEnd.replace('end', '');
                            this.dispatchEvent({ type: shortType, inputSource: src, frame: this._lastFrame });
                        }
                    };

                    check('trigger', 'selectstart', 'selectend');
                    check('grip', 'squeezestart', 'squeezeend');

                    // 3. 履歴更新
                    state.inputs[hand].prevButtons = { ...curr };
                }

                requestReferenceSpace(t) { return Promise.resolve({name:'viewer'}); }
                updateRenderState(p) {}
                end() { 
                    this.ended = true; 
                    this.dispatchEvent({type:'end', session:this});
                    return Promise.resolve(); 
                }
                
                requestAnimationFrame(cb) {
                    if(this.ended) return 0;
                    return window.requestAnimationFrame(t => {
                        this._lastFrame = { session: this }; // イベント用にframeオブジェクトを作成
                        
                        // 同期とイベント発火
                        this._updateAndFireEvents(0); // Left
                        this._updateAndFireEvents(1); // Right

                        cb(t, {
                            session: this,
                            getViewerPose: () => ({
                                transform: {
                                    position: {x:state.viewer.position[0], y:state.viewer.position[1], z:state.viewer.position[2], w:1},
                                    orientation: {x:state.viewer.quaternion[0], y:state.viewer.quaternion[1], z:state.viewer.quaternion[2], w:state.viewer.quaternion[3]}
                                },
                                views: [{
                                    eye:'left', projectionMatrix:[1,0,0,0, 0,1,0,0, 0,0,-1,-1, 0,0,-0.1,0],
                                    transform:{position:{x:0,y:0,z:0}, orientation:{x:0,y:0,z:0,w:1}},
                                    viewport:{x:0,y:0, width:window.innerWidth, height:window.innerHeight}
                                }]
                            }),
                            getPose: (src) => {
                                const d = state.inputs[src.handedness];
                                return {
                                    transform: {
                                        position: {x:d.position[0], y:d.position[1], z:d.position[2], w:1},
                                        orientation: {x:d.quaternion[0], y:d.quaternion[1], z:d.quaternion[2], w:d.quaternion[3]}
                                    }
                                };
                            }
                        });
                    });
                }
            }

            const mockXR = {
                isSessionSupported: m => Promise.resolve(m==='immersive-vr'),
                requestSession: m => Promise.resolve(new MockXRSession())
            };
            try { Object.defineProperty(navigator, 'xr', { value: mockXR, configurable: true }); }
            catch(e) { window.navigator.xr = mockXR; }
        })();
        <\/script>`;

        // === 2. Host App ===
        const app = {
            dom: {
                editor: document.getElementById('editor-screen'),
                emulator: document.getElementById('emulator-screen'),
                code: document.getElementById('code-area'),
                frame: document.getElementById('vr-frame'),
                status: document.getElementById('status-display'),
                stickL: document.getElementById('stick-left'),
                stickR: document.getElementById('stick-right'),
                knobL: document.getElementById('knob-left'),
                knobR: document.getElementById('knob-right')
            },
            state: {
                viewer: { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 },
                controllers: {
                    left:  { x: -0.2, y: 1.3, z: -0.4 },
                    right: { x:  0.2, y: 1.3, z: -0.4 }
                },
                gyroAlpha0: null,
                loopId: null
            },
            io: {
                save: () => { localStorage.setItem('vr_fix2_slot_'+document.getElementById('slot-select').value, app.dom.code.value); alert('Saved'); },
                load: () => { const v = localStorage.getItem('vr_fix2_slot_'+document.getElementById('slot-select').value); if(v) app.dom.code.value = v; },
                paste: async () => { app.dom.code.value = await navigator.clipboard.readText(); }
            },
            system: {
                init: () => {
                    app.io.load();
                    if(!app.dom.code.value) app.dom.code.value = app.sampleCode;
                    app.controls.init();
                },
                run: async () => {
                    if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try { await DeviceOrientationEvent.requestPermission(); } catch(e){}
                    }
                    app.dom.editor.style.display = 'none';
                    app.dom.emulator.style.display = 'block';
                    app.dom.frame.srcdoc = app.dom.code.value.replace('<head>', '<head>' + MOCK_LIB);

                    window.addEventListener('deviceorientation', app.tracking.onGyro);
                    app.dom.emulator.addEventListener('touchstart', app.tracking.onTouchStart, {passive:false});
                    app.dom.emulator.addEventListener('touchmove', app.tracking.onTouchMove, {passive:false});
                    app.dom.emulator.addEventListener('touchend', app.tracking.onTouchEnd, {passive:false});
                    
                    app.state.loopId = requestAnimationFrame(app.system.loop);
                },
                exit: () => {
                    app.dom.emulator.style.display = 'none';
                    app.dom.editor.style.display = 'flex';
                    app.dom.frame.srcdoc = '';
                    window.removeEventListener('deviceorientation', app.tracking.onGyro);
                    app.dom.emulator.removeEventListener('touchstart', app.tracking.onTouchStart);
                    app.dom.emulator.removeEventListener('touchmove', app.tracking.onTouchMove);
                    cancelAnimationFrame(app.state.loopId);
                    app.state.gyroAlpha0 = null;
                },
                loop: () => {
                    if(app.dom.emulator.style.display === 'none') return;
                    
                    // Viewer Quaternion
                    const { yaw, pitch } = app.state.viewer;
                    const c1=Math.cos(yaw/2), s1=Math.sin(yaw/2);
                    const c2=Math.cos(pitch/2), s2=Math.sin(pitch/2);
                    const q = [c1*s2, s1*c2, c1*c2, c1*c2+s1*s2]; // Simplified or standard mapping

                    // WebXR quaternion order is x, y, z, w
                    const qx = c1*s2; const qy = s1*c2; const qz = 0; const qw = c1*c2 + s1*s2; // Rough approx
                    
                    // Use a proper Euler to Quat for Y then X rotation (Yaw then Pitch)
                    // ZYX order:
                    // qx = s1 * c2 * c3 - c1 * s2 * s3 (using Roll=0)
                    // ... let's use the math helper
                    const finalQ = app.math.eulerToQuat(yaw, pitch, 0);

                    const payload = {
                        type: 'pose',
                        viewer: { position: [app.state.viewer.x, app.state.viewer.y, app.state.viewer.z], quaternion: finalQ },
                        left: { position: [app.state.controllers.left.x, app.state.controllers.left.y, app.state.controllers.left.z] },
                        right: { position: [app.state.controllers.right.x, app.state.controllers.right.y, app.state.controllers.right.z] }
                    };

                    if(app.dom.frame.contentWindow) {
                        app.dom.frame.contentWindow.postMessage({ source: 'VR_HOST', payload }, '*');
                    }
                    app.state.loopId = requestAnimationFrame(app.system.loop);
                }
            },
            controls: {
                init: () => {
                    document.querySelectorAll('.vr-btn').forEach(btn => {
                        const h = btn.dataset.hand;
                        const k = btn.dataset.key;
                        const send = (p) => {
                            if(app.dom.frame.contentWindow) {
                                app.dom.frame.contentWindow.postMessage({
                                    source:'VR_HOST', payload: { type:'pose', hand:h, buttons:{[k]:p} }
                                }, '*');
                            }
                        };
                        btn.addEventListener('touchstart', e=>{ e.preventDefault(); send(true); });
                        btn.addEventListener('touchend',   e=>{ e.preventDefault(); send(false); });
                    });
                }
            },
            tracking: {
                touches: {},
                onGyro: (e) => {
                    if(e.alpha === null) return;
                    if(app.state.gyroAlpha0 === null) app.state.gyroAlpha0 = e.alpha;
                    const radA = (e.alpha - app.state.gyroAlpha0) * (Math.PI/180);
                    const radB = (e.beta - 90) * (Math.PI/180); 
                    app.state.viewer.yaw = -radA;
                    app.state.viewer.pitch = radB;
                    app.dom.status.innerText = `Gyro: Active`;
                },
                onTouchStart: (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const trg = t.target;
                        
                        let type = null; let hand = null;
                        if(trg.closest('#joy-left')) { type='joy'; hand='left'; }
                        else if(trg.closest('#joy-right')) { type='joy'; hand='right'; }
                        else if(trg.closest('#pad-left')) { type='pad'; hand='left'; }
                        else if(trg.closest('#pad-right')) { type='pad'; hand='right'; }
                        else if(!trg.closest('#controls-overlay') && trg.id!=='exit-btn') { type='swipe'; }

                        if(type) {
                            const rect = type==='joy' ? trg.closest('.joy-container').getBoundingClientRect() : null;
                            app.tracking.touches[t.identifier] = { 
                                type, hand, 
                                startX: t.clientX, startY: t.clientY,
                                cx: rect?rect.left+rect.width/2:0, cy: rect?rect.top+rect.height/2:0,
                                ix: hand?app.state.controllers[hand].x:0,
                                iz: hand?app.state.controllers[hand].z:0
                            };
                        }
                    }
                },
                onTouchMove: (e) => {
                    e.preventDefault();
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const d = app.tracking.touches[t.identifier];
                        if(!d) continue;

                        if(d.type === 'joy') {
                            const maxR = 35;
                            let dx = t.clientX - d.cx; let dy = t.clientY - d.cy;
                            const dist = Math.sqrt(dx*dx+dy*dy);
                            if(dist > maxR) { dx *= maxR/dist; dy *= maxR/dist; }
                            
                            const el = d.hand==='left' ? app.dom.stickL : app.dom.stickR;
                            el.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                            
                            const ax = dx/maxR; const ay = dy/maxR;
                            
                            if(app.dom.frame.contentWindow) {
                                app.dom.frame.contentWindow.postMessage({
                                    source:'VR_HOST', payload: { type:'pose', hand:d.hand, axes:[ax, ay] }
                                }, '*');
                            }
                            // 左スティックは移動も兼ねる
                            if(d.hand === 'left') {
                                const yaw = app.state.viewer.yaw;
                                const speed = 0.05;
                                app.state.viewer.x += (Math.cos(yaw)*ax - Math.sin(yaw)*ay) * speed;
                                app.state.viewer.z += (Math.sin(yaw)*ax + Math.cos(yaw)*ay) * speed;
                            }
                        }
                        else if(d.type === 'pad') {
                            const dx = t.clientX - d.startX;
                            const dy = t.clientY - d.startY;
                            
                            // X / Z 移動
                            app.state.controllers[d.hand].x = d.ix + dx * 0.005;
                            app.state.controllers[d.hand].z = d.iz + dy * 0.005;

                            const knob = d.hand==='left' ? app.dom.knobL : app.dom.knobR;
                            // UI更新（範囲制限あり）
                            const limit = 40;
                            const uiX = Math.max(-limit, Math.min(limit, dx));
                            const uiY = Math.max(-limit/2, Math.min(limit/2, dy)); // 縦幅が狭いので
                            knob.style.transform = `translate(calc(-50% + ${uiX}px), calc(-50% + ${uiY}px))`;
                        }
                        else if(d.type === 'swipe' && !app.dom.status.innerText.includes('Active')) {
                            const dx = t.clientX - d.startX; const dy = t.clientY - d.startY;
                            app.state.viewer.yaw += dx * 0.005;
                            app.state.viewer.pitch += dy * 0.005;
                            d.startX = t.clientX; d.startY = t.clientY;
                        }
                    }
                },
                onTouchEnd: (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const d = app.tracking.touches[t.identifier];
                        if(!d) continue;
                        if(d.type === 'joy') {
                            const el = d.hand==='left' ? app.dom.stickL : app.dom.stickR;
                            el.style.transform = `translate(-50%, -50%)`;
                            if(app.dom.frame.contentWindow) {
                                app.dom.frame.contentWindow.postMessage({
                                    source:'VR_HOST', payload: { type:'pose', hand:d.hand, axes:[0,0] }
                                }, '*');
                            }
                        } else if(d.type === 'pad') {
                            const knob = d.hand==='left' ? app.dom.knobL : app.dom.knobR;
                            knob.style.transform = `translate(-50%, -50%)`;
                        }
                        delete app.tracking.touches[t.identifier];
                    }
                }
            },
            math: {
                eulerToQuat: (y, p, r) => {
                    const c1=Math.cos(y/2), s1=Math.sin(y/2);
                    const c2=Math.cos(p/2), s2=Math.sin(p/2);
                    const c3=Math.cos(r/2), s3=Math.sin(r/2);
                    // ZYX order
                    return [
                        c1*s2*c3 + s1*c2*s3,
                        s1*c2*c3 - c1*s2*s3,
                        c1*c2*s3 - s1*s2*c3,
                        c1*c2*c3 + s1*s2*s3
                    ];
                }
            },
            // Sample: 2つの箱（手）と中央の箱（動く）
            sampleCode: `<!DOCTYPE html>
<html>
<head>
  <style>body{margin:0;background:#111;color:#fff;}</style>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x303030);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    
    scene.add(new THREE.GridHelper(10, 10));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 5, 5);
    scene.add(light);

    // Hands
    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.2);
    const handL = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color: 0xff0000}));
    const handR = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({color: 0x0000ff}));
    scene.add(handL, handR);

    // Event Check
    const c1 = renderer.xr.getController(0);
    c1.addEventListener('selectstart', () => handL.material.emissive.setHex(0xffff00));
    c1.addEventListener('selectend', () => handL.material.emissive.setHex(0x000000));
    scene.add(c1);

    const c2 = renderer.xr.getController(1);
    c2.addEventListener('selectstart', () => handR.material.emissive.setHex(0xffff00));
    c2.addEventListener('selectend', () => handR.material.emissive.setHex(0x000000));
    scene.add(c2);

    renderer.setAnimationLoop((t, frame) => {
        if(!frame) { renderer.render(scene, camera); return; }
        
        const session = renderer.xr.getSession();
        session.inputSources.forEach(src => {
            const pose = frame.getPose(src, renderer.xr.getReferenceSpace());
            if(pose) {
                const mesh = src.handedness==='left'?handL:handR;
                mesh.position.copy(pose.transform.position);
                mesh.quaternion.copy(pose.transform.orientation);
            }
        });
        renderer.render(scene, camera);
    });

    // Auto Start
    setTimeout(async()=>{
        if(navigator.xr) {
            try{ 
                const s = await navigator.xr.requestSession('immersive-vr');
                renderer.xr.setSession(s);
            }catch(e){}
        }
    },500);
  <\/script>
</head>
<body></body>
</html>`
        };
        window.onload = app.system.init;
    </script>
</body>
</html>
