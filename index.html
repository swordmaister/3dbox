<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Quest 2 Emulator (State-Sync Logic)</title>
<style>
    /* --- 全体レイアウト --- */
    :root {
        --bg-color: #000;
        --zone-bg: rgba(50, 50, 50, 0.6);
        --accent: #007acc;
        --knob-color: rgba(255, 255, 0, 0.8);
    }
    body {
        margin: 0; padding: 0; background-color: var(--bg-color); color: #eee;
        font-family: sans-serif; height: 100vh; overflow: hidden;
        display: flex; flex-direction: column;
    }
    button { touch-action: manipulation; }

    /* --- エディタ画面 --- */
    #editor-screen { display: flex; flex-direction: column; height: 100%; padding: 8px; box-sizing: border-box; background: #111; }
    .toolbar { display: flex; justify-content: space-between; margin-bottom: 8px; }
    .btn { background: #333; color: #fff; border: 1px solid #555; padding: 6px 10px; border-radius: 4px; font-size: 12px; cursor: pointer; }
    .btn-run { background: #2e7d32; width: 100%; padding: 12px; font-weight: bold; font-size: 16px; margin-top: 5px; color:white; border:none; border-radius:4px; cursor: pointer;}
    #code-area { flex-grow: 1; background: #1e1e1e; color: #f8f8f2; border: 1px solid #444; padding: 10px; font-family: monospace; resize: none; font-size: 12px; }

    /* --- エミュレータ画面 --- */
    #emulator-screen { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; }
    
    /* VR表示レイヤー (奥) */
    #vr-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 1;
    }
    #vr-frame { width: 100%; height: 100%; border: none; display: block; }

    /* UI操作レイヤー (手前) */
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 10; pointer-events: none; /* UIのないところは透過 */
        display: flex; flex-direction: column; justify-content: space-between;
    }

    #ui-header {
        padding: 10px; display: flex; justify-content: space-between; pointer-events: none;
    }
    #exit-btn {
        pointer-events: auto; background: #d32f2f; color: white; width: 40px; height: 40px;
        border-radius: 50%; display: flex; justify-content: center; align-items: center; 
        font-weight: bold; cursor: pointer; border: 2px solid #fff;
        box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    #status-display { 
        background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; 
        color: #0f0; font-size: 12px; pointer-events: none;
    }

    /* コントローラーオーバーレイ */
    #controls-container {
        width: 100%; height: 45%; /* 画面下半分 */
        display: flex; justify-content: space-between; align-items: flex-end;
        padding: 5px; box-sizing: border-box; pointer-events: none;
    }

    .control-zone {
        pointer-events: auto; /* ここだけ操作可能 */
        background: var(--zone-bg); border-radius: 12px 12px 0 0;
        padding: 5px; display: flex; flex-direction: column; align-items: center; justify-content: space-around;
        width: 49%; height: 100%; border: 1px solid rgba(255,255,255,0.1); 
        box-sizing: border-box; backdrop-filter: blur(4px);
    }
    
    .label { font-size: 10px; color: #aaa; font-weight: bold; text-align: center; width: 100%; margin-bottom: 2px; }

    /* コンポーネント共通 */
    .row { display: flex; gap: 8px; justify-content: center; width: 100%; align-items: center;}

    /* ジョイスティック */
    .joy-container {
        width: 60px; height: 60px; background: rgba(0,0,0,0.3); border: 1px solid #555; border-radius: 50%;
        position: relative; touch-action: none; flex-shrink: 0;
    }
    .joy-stick {
        width: 26px; height: 26px; background: var(--accent); border-radius: 50%;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        box-shadow: 0 0 5px var(--accent); pointer-events: none;
    }

    /* ボタン */
    .vr-btn {
        width: 38px; height: 38px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
        border-radius: 50%; color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
        user-select: none; font-size: 10px; transition: background 0.05s;
    }
    .vr-btn.active { background: var(--accent); border-color: #fff; transform: scale(0.95); }
    
    /* トラッキングパッド (2D Position) */
    .pos-pad {
        width: 90%; height: 60px; 
        background: rgba(0,0,0,0.4); border: 1px dashed #666; border-radius: 6px;
        position: relative; touch-action: none; overflow: hidden;
    }
    .pos-knob {
        width: 16px; height: 16px; background: var(--knob-color); border-radius: 50%;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none;
        box-shadow: 0 0 5px yellow;
    }
    .pad-hint {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: rgba(255,255,255,0.2); font-size: 10px; pointer-events: none; text-align: center;
        white-space: nowrap;
    }

</style>
</head>
<body>

    <div id="editor-screen">
        <div class="toolbar">
            <select id="slot-select">
                <option value="1">Slot 1</option><option value="2">Slot 2</option><option value="3">Slot 3</option>
            </select>
            <div>
                <button class="btn" onclick="app.io.save()">Save</button>
                <button class="btn" onclick="app.io.load()">Load</button>
                <button class="btn" onclick="app.io.paste()">Paste</button>
            </div>
        </div>
        <textarea id="code-area" spellcheck="false" placeholder="ここにWebXR対応HTMLを貼り付け"></textarea>
        <button class="btn-run" onclick="app.system.run()">▶ VR START</button>
    </div>

    <div id="emulator-screen">
        <div id="vr-layer">
            <iframe id="vr-frame"></iframe>
        </div>

        <div id="ui-layer">
            <div id="ui-header">
                <div id="exit-btn" onclick="app.system.exit()">×</div>
                <div id="status-display">Gyro: Waiting...</div>
            </div>
            
            <div id="controls-container">
                <div class="control-zone">
                    <div class="label">LEFT (Move)</div>
                    <div class="joy-container" id="joy-left"><div class="joy-stick" id="stick-left"></div></div>
                    
                    <div class="row">
                        <div class="vr-btn" data-hand="left" data-key="X">X</div>
                        <div class="vr-btn" data-hand="left" data-key="Y">Y</div>
                        <div class="vr-btn" data-hand="left" data-key="menu">≡</div>
                    </div>
                    <div class="row">
                        <div class="vr-btn" data-hand="left" data-key="trigger">Trig</div>
                        <div class="vr-btn" data-hand="left" data-key="grip">Grip</div>
                    </div>
                    
                    <div class="pos-pad" id="pad-left">
                        <div class="pad-hint">Pos X/Z</div>
                        <div class="pos-knob" id="knob-left"></div>
                    </div>
                </div>

                <div class="control-zone">
                    <div class="label">RIGHT (Turn)</div>
                    <div class="joy-container" id="joy-right"><div class="joy-stick" id="stick-right"></div></div>
                    
                    <div class="row">
                        <div class="vr-btn" data-hand="right" data-key="A">A</div>
                        <div class="vr-btn" data-hand="right" data-key="B">B</div>
                    </div>
                    <div class="row">
                        <div class="vr-btn" data-hand="right" data-key="trigger">Trig</div>
                        <div class="vr-btn" data-hand="right" data-key="grip">Grip</div>
                    </div>

                    <div class="pos-pad" id="pad-right">
                        <div class="pad-hint">Pos X/Z</div>
                        <div class="pos-knob" id="knob-right"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === 1. Mock Library (注入用コード: iframe内で実行) ===
        // 仕様変更：イベント発火をState監視型に変更し、prevButtonsをDeepCopyする
        const MOCK_LIB = `
        <script>
        (function() {
            console.log("[VR Mock] Initializing State-Sync Logic...");
            
            // 内部状態 (Source of Truth)
            const state = {
                viewer: { position: [0, 1.6, 0], quaternion: [0, 0, 0, 1] },
                inputs: {
                    left:  { axes: [0,0], buttons: {}, position: [-0.2, 1.4, -0.5], quaternion: [0,0,0,1], prevButtons: {} },
                    right: { axes: [0,0], buttons: {}, position: [ 0.2, 1.4, -0.5], quaternion: [0,0,0,1], prevButtons: {} }
                }
            };

            // Hostからのデータ受信 (Stateの更新のみを行う)
            window.addEventListener('message', (e) => {
                if (!e.data || e.data.source !== 'VR_HOST') return;
                const msg = e.data.payload;
                
                if (msg.type === 'sync') {
                    // Viewer更新
                    if (msg.viewer) state.viewer = msg.viewer;
                    
                    // Controllers更新
                    ['left', 'right'].forEach(hand => {
                        if (msg[hand]) {
                            const target = state.inputs[hand];
                            const source = msg[hand];
                            if(source.position) target.position = source.position;
                            if(source.axes) target.axes = source.axes;
                            // ボタン状態を丸ごと上書き (Host側で管理しているため)
                            if(source.buttons) target.buttons = source.buttons;
                        }
                    });
                }
            });

            // Mock Gamepad
            class MockGamepad {
                constructor() {
                    this.buttons = Array(7).fill(0).map(() => ({ pressed: false, value: 0 }));
                    this.axes = [0, 0, 0, 0];
                    this.mapping = 'xr-standard';
                }
                
                update(data, hand) {
                    // Axes Update (Quest: X=2, Y=3)
                    if(data.axes) {
                        this.axes[2] = data.axes[0]; 
                        this.axes[3] = data.axes[1];
                    } else {
                        this.axes[2] = 0; this.axes[3] = 0;
                    }

                    // Buttons Update
                    const mapBtn = (key, idx) => {
                        const val = !!data.buttons[key];
                        this.buttons[idx].pressed = val;
                        this.buttons[idx].value = val ? 1 : 0;
                    };
                    
                    // Mapping: 0:Trig, 1:Grip, 2:Pad, 3:Stick, 4:A/X, 5:B/Y, 6:Menu
                    mapBtn('trigger', 0);
                    mapBtn('grip', 1);
                    mapBtn(hand==='left' ? 'X' : 'A', 4);
                    mapBtn(hand==='left' ? 'Y' : 'B', 5);
                    mapBtn('menu', 6);
                }
            }

            // Mock InputSource
            class MockInputSource {
                constructor(hand) {
                    this.handedness = hand;
                    this.targetRayMode = 'tracked-pointer';
                    this.profiles = ['oculus-touch-v3', 'oculus-touch'];
                    this.gamepad = new MockGamepad();
                }
            }

            // Mock Session
            class MockXRSession extends EventTarget {
                constructor() {
                    super();
                    this.ended = false;
                    this.renderState = { baseLayer: null };
                    this._inputSources = [
                        new MockInputSource('left'),
                        new MockInputSource('right')
                    ];
                    this._listeners = {};
                    this._lastFrame = null;
                }

                get inputSources() { return this._inputSources; }

                addEventListener(type, cb) { 
                    if(!this._listeners[type]) this._listeners[type]=[]; 
                    this._listeners[type].push(cb); 
                }
                removeEventListener(type, cb) {
                    if(this._listeners[type]) this._listeners[type] = this._listeners[type].filter(c => c!==cb);
                }
                dispatchEvent(event) {
                    if(this._listeners[event.type]) this._listeners[event.type].forEach(cb => cb(event));
                }
                
                // フレームごとの処理：ボタン変化の検出とイベント発火
                _processEvents(index) {
                    const src = this._inputSources[index];
                    const hand = src.handedness;
                    const inputState = state.inputs[hand];
                    const curr = inputState.buttons;
                    const prev = inputState.prevButtons; // ここは前フレームのSnapshot
                    
                    // Gamepadオブジェクトを最新状態に同期
                    src.gamepad.update(inputState, hand);

                    // 変化検知ロジック
                    const check = (key, typeStart, typeEnd) => {
                        const isDown = !!curr[key];
                        const wasDown = !!prev[key];
                        
                        if (isDown && !wasDown) {
                            this.dispatchEvent({ type: typeStart, inputSource: src, frame: this._lastFrame });
                        }
                        if (!isDown && wasDown) {
                            this.dispatchEvent({ type: typeEnd, inputSource: src, frame: this._lastFrame });
                            // select/squeezeはend時にも発火(WebXR仕様)
                            const shortType = typeEnd.replace('end', ''); 
                            this.dispatchEvent({ type: shortType, inputSource: src, frame: this._lastFrame });
                        }
                    };

                    check('trigger', 'selectstart', 'selectend');
                    check('grip', 'squeezestart', 'squeezeend');

                    // 重要: prevButtons を DEEP COPY で更新 (仕様⑤対応)
                    inputState.prevButtons = JSON.parse(JSON.stringify(curr));
                }

                requestReferenceSpace(t) { return Promise.resolve({name:'viewer'}); }
                updateRenderState(p) {}
                end() { 
                    this.ended = true; 
                    this.dispatchEvent({type:'end', session:this});
                    return Promise.resolve(); 
                }
                
                requestAnimationFrame(cb) {
                    if(this.ended) return 0;
                    return window.requestAnimationFrame(t => {
                        this._lastFrame = { session: this };
                        
                        // イベント処理
                        this._processEvents(0); // Left
                        this._processEvents(1); // Right

                        cb(t, {
                            session: this,
                            getViewerPose: () => ({
                                transform: {
                                    position: {x:state.viewer.position[0], y:state.viewer.position[1], z:state.viewer.position[2], w:1},
                                    orientation: {x:state.viewer.quaternion[0], y:state.viewer.quaternion[1], z:state.viewer.quaternion[2], w:state.viewer.quaternion[3]}
                                },
                                views: [{
                                    eye:'left', projectionMatrix:[1,0,0,0, 0,1,0,0, 0,0,-1,-1, 0,0,-0.1,0],
                                    transform:{position:{x:0,y:0,z:0}, orientation:{x:0,y:0,z:0,w:1}},
                                    viewport:{x:0,y:0, width:window.innerWidth, height:window.innerHeight}
                                }]
                            }),
                            getPose: (src) => {
                                const d = state.inputs[src.handedness];
                                return {
                                    transform: {
                                        position: {x:d.position[0], y:d.position[1], z:d.position[2], w:1},
                                        orientation: {x:d.quaternion[0], y:d.quaternion[1], z:d.quaternion[2], w:d.quaternion[3]}
                                    }
                                };
                            }
                        });
                    });
                }
            }

            const mockXR = {
                isSessionSupported: m => Promise.resolve(m==='immersive-vr'),
                requestSession: m => Promise.resolve(new MockXRSession())
            };
            // 既存のnavigator.xrを上書き
            try { Object.defineProperty(navigator, 'xr', { value: mockXR, configurable: true }); }
            catch(e) { window.navigator.xr = mockXR; }
        })();
        <\/script>`;

        // === 2. Host App (エミュレータ本体) ===
        const app = {
            dom: {
                editor: document.getElementById('editor-screen'),
                emulator: document.getElementById('emulator-screen'),
                code: document.getElementById('code-area'),
                frame: document.getElementById('vr-frame'),
                status: document.getElementById('status-display'),
                stickL: document.getElementById('stick-left'),
                stickR: document.getElementById('stick-right'),
                knobL: document.getElementById('knob-left'),
                knobR: document.getElementById('knob-right')
            },
            // Host側で全ての状態を管理する (Source of Truth)
            state: {
                viewer: { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 },
                controllers: {
                    left:  { x: -0.2, y: 1.3, z: -0.4, axes: [0,0], buttons: {} },
                    right: { x:  0.2, y: 1.3, z: -0.4, axes: [0,0], buttons: {} }
                },
                gyroAlpha0: null,
                loopId: null
            },
            io: {
                save: () => { localStorage.setItem('vr_fix3_slot_'+document.getElementById('slot-select').value, app.dom.code.value); alert('Saved'); },
                load: () => { const v = localStorage.getItem('vr_fix3_slot_'+document.getElementById('slot-select').value); if(v) app.dom.code.value = v; },
                paste: async () => { app.dom.code.value = await navigator.clipboard.readText(); }
            },
            system: {
                init: () => {
                    app.io.load();
                    if(!app.dom.code.value) app.dom.code.value = app.sampleCode;
                    app.controls.init();
                },
                run: async () => {
                    if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try { await DeviceOrientationEvent.requestPermission(); } catch(e){}
                    }
                    app.dom.editor.style.display = 'none';
                    app.dom.emulator.style.display = 'block';
                    
                    // Mockコードを注入して起動
                    const code = app.dom.code.value;
                    const injectPos = code.indexOf('<head>') + 6;
                    const finalCode = code.slice(0, injectPos) + MOCK_LIB + code.slice(injectPos);
                    app.dom.frame.srcdoc = finalCode;

                    window.addEventListener('deviceorientation', app.tracking.onGyro);
                    
                    // Touchイベントは「操作レイヤー」で受け取る
                    const layer = document.getElementById('ui-layer');
                    layer.addEventListener('touchstart', app.tracking.onTouchStart, {passive:false});
                    layer.addEventListener('touchmove', app.tracking.onTouchMove, {passive:false});
                    layer.addEventListener('touchend', app.tracking.onTouchEnd, {passive:false});
                    
                    app.state.loopId = requestAnimationFrame(app.system.loop);
                },
                exit: () => {
                    app.dom.emulator.style.display = 'none';
                    app.dom.editor.style.display = 'flex';
                    app.dom.frame.srcdoc = '';
                    window.removeEventListener('deviceorientation', app.tracking.onGyro);
                    const layer = document.getElementById('ui-layer');
                    layer.removeEventListener('touchstart', app.tracking.onTouchStart);
                    layer.removeEventListener('touchmove', app.tracking.onTouchMove);
                    layer.removeEventListener('touchend', app.tracking.onTouchEnd);
                    cancelAnimationFrame(app.state.loopId);
                    app.state.gyroAlpha0 = null;
                },
                loop: () => {
                    if(app.dom.emulator.style.display === 'none') return;
                    
                    // Viewer Quaternion Calculation
                    const { yaw, pitch } = app.state.viewer;
                    const finalQ = app.math.eulerToQuat(yaw, pitch, 0);

                    // Payload作成: ボタン状態なども含めて「全状態」を送る (仕様①)
                    const payload = {
                        type: 'sync',
                        viewer: { position: [app.state.viewer.x, app.state.viewer.y, app.state.viewer.z], quaternion: finalQ },
                        left: { 
                            position: [app.state.controllers.left.x, app.state.controllers.left.y, app.state.controllers.left.z],
                            axes: app.state.controllers.left.axes,
                            buttons: app.state.controllers.left.buttons
                        },
                        right: { 
                            position: [app.state.controllers.right.x, app.state.controllers.right.y, app.state.controllers.right.z],
                            axes: app.state.controllers.right.axes,
                            buttons: app.state.controllers.right.buttons
                        }
                    };

                    if(app.dom.frame.contentWindow) {
                        app.dom.frame.contentWindow.postMessage({ source: 'VR_HOST', payload }, '*');
                    }
                    app.state.loopId = requestAnimationFrame(app.system.loop);
                }
            },
            controls: {
                init: () => {
                    // Host側の状態管理: DOMイベントはStateを更新するだけ
                    // 送信はloopが一括で行う
                    document.querySelectorAll('.vr-btn').forEach(btn => {
                        const h = btn.dataset.hand;
                        const k = btn.dataset.key;
                        
                        btn.addEventListener('touchstart', e=>{ 
                            e.preventDefault(); 
                            app.state.controllers[h].buttons[k] = true;
                            btn.classList.add('active');
                        });
                        btn.addEventListener('touchend',   e=>{ 
                            e.preventDefault(); 
                            app.state.controllers[h].buttons[k] = false;
                            btn.classList.remove('active');
                        });
                    });
                }
            },
            tracking: {
                touches: {},
                onGyro: (e) => {
                    if(e.alpha === null) return;
                    if(app.state.gyroAlpha0 === null) app.state.gyroAlpha0 = e.alpha;
                    const radA = (e.alpha - app.state.gyroAlpha0) * (Math.PI/180);
                    const radB = (e.beta - 90) * (Math.PI/180); 
                    app.state.viewer.yaw = -radA;
                    app.state.viewer.pitch = radB;
                    app.dom.status.innerText = `Gyro: Active`;
                },
                onTouchStart: (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const trg = t.target;
                        
                        let type = null; let hand = null;
                        if(trg.closest('#joy-left')) { type='joy'; hand='left'; }
                        else if(trg.closest('#joy-right')) { type='joy'; hand='right'; }
                        else if(trg.closest('#pad-left')) { type='pad'; hand='left'; }
                        else if(trg.closest('#pad-right')) { type='pad'; hand='right'; }
                        else if(!trg.closest('.control-zone') && trg.id!=='exit-btn') { type='swipe'; }

                        if(type) {
                            const rect = (type==='joy') ? trg.closest('.joy-container').getBoundingClientRect() : null;
                            const padRect = (type==='pad') ? trg.closest('.pos-pad').getBoundingClientRect() : null;

                            app.tracking.touches[t.identifier] = { 
                                type, hand, 
                                startX: t.clientX, startY: t.clientY,
                                // Joy用中心座標
                                cx: rect?rect.left+rect.width/2:0, cy: rect?rect.top+rect.height/2:0,
                                // Pad用初期座標
                                ix: hand?app.state.controllers[hand].x:0,
                                iz: hand?app.state.controllers[hand].z:0
                            };
                        }
                    }
                },
                onTouchMove: (e) => {
                    e.preventDefault();
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const d = app.tracking.touches[t.identifier];
                        if(!d) continue;

                        if(d.type === 'joy') {
                            const maxR = 30; // 半径
                            let dx = t.clientX - d.cx; let dy = t.clientY - d.cy;
                            const dist = Math.sqrt(dx*dx+dy*dy);
                            if(dist > maxR) { dx *= maxR/dist; dy *= maxR/dist; }
                            
                            const el = d.hand==='left' ? app.dom.stickL : app.dom.stickR;
                            el.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                            
                            // 軸計算 (-1 ~ 1)
                            let ax = dx/maxR; let ay = dy/maxR;
                            
                            // デッドゾーン (仕様⑥)
                            if(Math.abs(ax) < 0.1) ax = 0;
                            if(Math.abs(ay) < 0.1) ay = 0;

                            // State更新
                            app.state.controllers[d.hand].axes = [ax, ay];

                            // 左スティックでの移動 (FPSライクな移動)
                            if(d.hand === 'left' && (ax!==0 || ay!==0)) {
                                const yaw = app.state.viewer.yaw;
                                const speed = 0.04;
                                app.state.viewer.x += (Math.cos(yaw)*ax - Math.sin(yaw)*ay) * speed;
                                app.state.viewer.z += (Math.sin(yaw)*ax + Math.cos(yaw)*ay) * speed;
                            }
                            // 右スティックでのスナップターン (仕様⑥)
                            if(d.hand === 'right' && Math.abs(ax) > 0.8) {
                                // 連続ターン防止のためのフラグ管理などは省略して簡易実装
                                app.state.viewer.yaw -= ax * 0.05; 
                            }
                        }
                        else if(d.type === 'pad') {
                            // コントローラー位置移動 (仕様④)
                            const dx = t.clientX - d.startX;
                            const dy = t.clientY - d.startY;
                            
                            // 移動感度
                            const sensitivity = 0.005;
                            app.state.controllers[d.hand].x = d.ix + dx * sensitivity;
                            app.state.controllers[d.hand].z = d.iz + dy * sensitivity;

                            const knob = d.hand==='left' ? app.dom.knobL : app.dom.knobR;
                            const limit = 40;
                            const uiX = Math.max(-limit, Math.min(limit, dx));
                            const uiY = Math.max(-25, Math.min(25, dy)); 
                            knob.style.transform = `translate(calc(-50% + ${uiX}px), calc(-50% + ${uiY}px))`;
                        }
                        else if(d.type === 'swipe' && !app.dom.status.innerText.includes('Active')) {
                            // Gyroがない時の代替視点操作
                            const dx = t.clientX - d.startX; const dy = t.clientY - d.startY;
                            app.state.viewer.yaw += dx * 0.005;
                            app.state.viewer.pitch += dy * 0.005;
                            d.startX = t.clientX; d.startY = t.clientY;
                        }
                    }
                },
                onTouchEnd: (e) => {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        const t = e.changedTouches[i];
                        const d = app.tracking.touches[t.identifier];
                        if(!d) continue;
                        
                        if(d.type === 'joy') {
                            const el = d.hand==='left' ? app.dom.stickL : app.dom.stickR;
                            el.style.transform = `translate(-50%, -50%)`;
                            // Stateリセット
                            app.state.controllers[d.hand].axes = [0,0];
                        } else if(d.type === 'pad') {
                            const knob = d.hand==='left' ? app.dom.knobL : app.dom.knobR;
                            knob.style.transform = `translate(-50%, -50%)`;
                        }
                        delete app.tracking.touches[t.identifier];
                    }
                }
            },
            math: {
                // Euler -> Quaternion (Y -> X order approximated for simple look)
                eulerToQuat: (y, p, r) => {
                    const c1=Math.cos(y/2), s1=Math.sin(y/2);
                    const c2=Math.cos(p/2), s2=Math.sin(p/2);
                    const c3=Math.cos(r/2), s3=Math.sin(r/2);
                    // ZYX order
                    return [
                        c1*s2*c3 + s1*c2*s3,
                        s1*c2*c3 - c1*s2*s3,
                        c1*c2*s3 - s1*s2*c3,
                        c1*c2*c3 + s1*s2*s3
                    ];
                }
            },
            // Sample: 2つの箱（手）
            sampleCode: `<!DOCTYPE html>
<html>
<head>
  <style>body{margin:0;background:#111;color:#fff;overflow:hidden;}</style>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    
    // Grid & Light
    scene.add(new THREE.GridHelper(10, 10, 0x888888, 0x444444));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 5, 5);
    scene.add(light);

    // Hands Visuals
    const geometry = new THREE.BoxGeometry(0.08, 0.08, 0.2);
    const matL = new THREE.MeshLambertMaterial({color: 0xff0000});
    const matR = new THREE.MeshLambertMaterial({color: 0x0000ff});
    const handL = new THREE.Mesh(geometry, matL);
    const handR = new THREE.Mesh(geometry, matR);
    scene.add(handL, handR);

    // Event Listeners (Test)
    const c1 = renderer.xr.getController(0); // Left
    c1.addEventListener('selectstart', () => { console.log('L Trig!'); matL.emissive.setHex(0xffff00); });
    c1.addEventListener('selectend',   () => { matL.emissive.setHex(0x000000); });
    c1.addEventListener('squeezestart',() => { console.log('L Grip!'); matL.wireframe = true; });
    c1.addEventListener('squeezeend',  () => { matL.wireframe = false; });
    scene.add(c1);

    const c2 = renderer.xr.getController(1); // Right
    c2.addEventListener('selectstart', () => { console.log('R Trig!'); matR.emissive.setHex(0xffff00); });
    c2.addEventListener('selectend',   () => { matR.emissive.setHex(0x000000); });
    scene.add(c2);

    renderer.setAnimationLoop((t, frame) => {
        if(!frame) { renderer.render(scene, camera); return; }
        
        const session = renderer.xr.getSession();
        session.inputSources.forEach(src => {
            const pose = frame.getPose(src, renderer.xr.getReferenceSpace());
            if(pose) {
                const mesh = src.handedness==='left' ? handL : handR;
                mesh.position.copy(pose.transform.position);
                mesh.quaternion.copy(pose.transform.orientation);
            }
        });
        renderer.render(scene, camera);
    });

    // Auto Start VR
    setTimeout(async()=>{
        if(navigator.xr) {
            try{ 
                const s = await navigator.xr.requestSession('immersive-vr');
                renderer.xr.setSession(s);
            }catch(e){ console.log('VR Init Fail', e); }
        }
    },1000);
  <\/script>
</head>
<body></body>
</html>`
        };
        window.onload = app.system.init;
    </script>
</body>
</html>
