<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Mobile VR Dev Kit (トラッキング対応)</title>
<style>
    /* --- 基本スタイル --- */
    :root {
        --bg-color: #1e1e1e;
        --editor-bg: #2d2d2d;
        --text-color: #e0e0e0;
        --accent-color: #007acc;
        --danger-color: #d9534f;
    }
    body {
        margin: 0; padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: monospace;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    button, select {
        font-family: sans-serif;
        touch-action: manipulation;
    }

    /* --- 1. エディタ画面 UI (変更なし) --- */
    #editor-screen {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 10px;
        box-sizing: border-box;
    }
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
        align-items: center;
    }
    .toolbar-group {
        display: flex;
        gap: 4px;
        background: #333;
        padding: 4px;
        border-radius: 6px;
    }
    select {
        background: #444; color: #fff; border: 1px solid #555;
        padding: 8px; border-radius: 4px; font-size: 14px;
    }
    .btn {
        background: #444; color: #fff; border: none;
        padding: 8px 12px; border-radius: 4px; font-size: 13px; cursor: pointer;
    }
    .btn:active { background: #666; }
    .btn-primary { background: var(--accent-color); font-weight: bold; }
    .btn-danger { background: var(--danger-color); }
    
    #code-area {
        flex-grow: 1;
        background-color: var(--editor-bg);
        color: #fff;
        border: 1px solid #444;
        padding: 10px;
        font-size: 14px;
        resize: none;
        outline: none;
        border-radius: 4px;
        white-space: pre;
        overflow-x: auto;
    }

    #run-btn {
        margin-top: 10px;
        padding: 15px;
        font-size: 18px;
        background: #0a0;
        color: white;
        border: none;
        border-radius: 6px;
        width: 100%;
    }

    /* --- 2. VRエミュレータ画面 UI --- */
    #emulator-screen {
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #000;
        z-index: 100;
    }
    
    /* 実行されるiframe */
    #vr-frame {
        width: 100%; height: 100%; border: none;
        display: block;
    }

    /* オーバーレイUI */
    #exit-btn {
        position: absolute;
        top: 10px; left: 10px;
        width: 40px; height: 40px;
        background: rgba(255, 0, 0, 0.7);
        color: white;
        border: 2px solid white;
        border-radius: 50%;
        font-size: 24px;
        line-height: 36px;
        text-align: center;
        z-index: 200;
        cursor: pointer;
    }
    
    #controls-overlay {
        position: absolute;
        bottom: 0; left: 0; width: 100%; height: 40%;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        padding: 10px;
        box-sizing: border-box;
    }

    /* コントローラーパーツ */
    .control-zone {
        pointer-events: auto;
        background: rgba(50, 50, 50, 0.5);
        border-radius: 10px;
        padding: 5px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        width: 30%; /* 3つのゾーンを配置するため幅を調整 */
    }

    .v-btn {
        width: 40px; height: 40px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        color: white;
        font-weight: bold;
        display: flex; justify-content: center; align-items: center;
        user-select: none;
    }
    .v-btn:active { background: rgba(0, 255, 0, 0.5); border-color: #0f0; }

    /* トラッキングパッド */
    .tracking-pad {
        width: 80px; height: 80px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px dashed rgba(255, 255, 255, 0.5);
        position: relative;
        touch-action: none;
        margin-bottom: 5px;
    }
    .pad-label {
        color: #aaa; font-size: 10px; margin-bottom: 5px;
    }

    #joystick-area {
        width: 80px; height: 80px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        position: relative;
        touch-action: none;
    }
    #joystick-knob {
        width: 30px; height: 30px;
        background: rgba(0, 150, 255, 0.8);
        border-radius: 50%;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }
    
    #gyro-status {
        position: absolute; top: 10px; right: 10px;
        color: lime; font-size: 12px;
        background: rgba(0,0,0,0.5); padding: 4px;
    }
</style>
</head>
<body>

    <div id="editor-screen">
        <div class="toolbar">
            <div class="toolbar-group">
                <select id="slot-select">
                    <option value="1">Slot 1</option>
                    <option value="2">Slot 2</option>
                    <option value="3">Slot 3</option>
                    <option value="4">Slot 4</option>
                    <option value="5">Slot 5</option>
                </select>
                <button class="btn" onclick="saveSlot()">保存</button>
                <button class="btn" onclick="loadSlot()">読込</button>
            </div>
            <div class="toolbar-group">
                <button class="btn" onclick="copyCode()">コピー</button>
                <button class="btn" onclick="pasteCode()">ペースト</button>
                <button class="btn btn-danger" onclick="clearCode()">クリア</button>
            </div>
        </div>
        
        <textarea id="code-area" spellcheck="false" placeholder="ここにWebXR対応のHTMLコードを貼り付けてください..."></textarea>
        
        <button id="run-btn" onclick="runVR()">VRモード起動 (RUN)</button>
    </div>

    <div id="emulator-screen">
        <div id="exit-btn" onclick="exitVR()">×</div>
        <div id="gyro-status">Gyro: Ready</div>
        
        <iframe id="vr-frame"></iframe>

        <div id="controls-overlay">
            
            <div class="control-zone">
                <span class="pad-label">LEFT TRACKING (X/Y)</span>
                <div class="tracking-pad" id="left-tracking-pad"></div>
                <div style="display:flex; gap:5px;">
                    <div class="v-btn" data-key="trigger" data-hand="left">Trig</div>
                    <div class="v-btn" data-key="grip" data-hand="left">Grip</div>
                </div>
            </div>

            <div class="control-zone">
                <span class="pad-label">HMD MOVE (Joystick)</span>
                <div id="joystick-area">
                    <div id="joystick-knob"></div>
                </div>
                <div style="display:flex; gap:5px;">
                    <div class="v-btn" data-key="menu" data-hand="left">MENU</div>
                    <div class="v-btn" data-key="X" data-hand="left">X/Y</div>
                </div>
            </div>
            
            <div class="control-zone">
                <span class="pad-label">RIGHT TRACKING (X/Y)</span>
                <div class="tracking-pad" id="right-tracking-pad"></div>
                <div style="display:flex; gap:5px;">
                    <div class="v-btn" data-key="trigger" data-hand="right">Trig</div>
                    <div class="v-btn" data-key="grip" data-hand="right">Grip</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === 1. WebXR Mock Library (Iframe内に注入されるコード) ===
        const MOCK_LIB_CODE = `
        <script>
        (function() {
            console.log("WebXR Emulator Mock Initialized inside Iframe");
            
            // 内部状態
            const state = {
                position: [0, 1.6, 0],
                quaternion: [0, 0, 0, 1],
                inputs: {
                    left: { 
                        axes: [0,0], buttons: {}, 
                        position: [-0.3, 1.4, -0.5], // 初期位置
                        quaternion: [0, 0, 0, 1] 
                    },
                    right: { 
                        axes: [0,0], buttons: {}, 
                        position: [0.3, 1.4, -0.5], // 初期位置
                        quaternion: [0, 0, 0, 1] 
                    }
                }
            };

            // 親ウィンドウからのメッセージ受信リスナー
            window.addEventListener('message', (e) => {
                const msg = e.data;
                if (!msg || !msg.type || msg.source !== 'VR_HOST') return; 

                if (msg.type === 'updateInput') {
                    const input = state.inputs[msg.hand];
                    if (msg.axes) input.axes = msg.axes;
                    if (msg.buttons) Object.assign(input.buttons, msg.buttons);
                }
                else if (msg.type === 'updatePose') {
                    if (msg.position) state.position = msg.position;
                    if (msg.quaternion) state.quaternion = msg.quaternion;
                    
                    if (msg.handPose) {
                        const hand = state.inputs[msg.handPose.hand];
                        if (msg.handPose.position) hand.position = msg.handPose.position;
                        if (msg.handPose.quaternion) hand.quaternion = msg.handPose.quaternion;
                    }
                }
            });

            // --- WebXR API Mock Class Definitions ---
            
            class MockXRSession {
                constructor() {
                    this.ended = false;
                    this.inputSources = [
                        this._createInputSource('left'),
                        this._createInputSource('right')
                    ];
                    this.renderState = { baseLayer: null };
                    this.viewerSpace = { name: 'viewer' };
                }

                _createInputSource(hand) {
                    return {
                        handedness: hand,
                        targetRayMode: 'tracked-pointer',
                        profiles: ['oculus-touch-v2'],
                        gamepad: {
                            buttons: [
                                { pressed: false, value: 0 }, // 0: Trigger
                                { pressed: false, value: 0 }, // 1: Grip
                                { pressed: false, value: 0 }, // 2: X/A
                                { pressed: false, value: 0 }, // 3: Y/B
                                { pressed: false, value: 0 }, // 4: Menu/Oculus
                            ],
                            axes: [0, 0] // 5, 6
                        }
                    };
                }

                _updateInputSources() {
                    const mapBtn = (btnState) => ({ pressed: !!btnState, value: btnState ? 1 : 0 });
                    
                    ['left', 'right'].forEach((hand, index) => {
                        const input = state.inputs[hand];
                        const gp = this.inputSources[index].gamepad.buttons;
                        
                        // Axes
                        this.inputSources[index].gamepad.axes = input.axes;

                        // Buttons mapping (簡易的な標準WebXRマッピング)
                        gp[0] = mapBtn(input.buttons.trigger);
                        gp[1] = mapBtn(input.buttons.grip);
                        gp[2] = mapBtn(input.buttons.X || input.buttons.A);
                        gp[3] = mapBtn(input.buttons.Y || input.buttons.B);
                        gp[4] = mapBtn(input.buttons.menu);
                    });
                }

                requestReferenceSpace(type) { return Promise.resolve(this.viewerSpace); }
                
                getViewerPose(refSpace) {
                     this._updateInputSources();
                     const width = window.innerWidth;
                     const height = window.innerHeight;
                     
                     return {
                        transform: {
                            position: { x: state.position[0], y: state.position[1], z: state.position[2], w: 1 },
                            orientation: { x: state.quaternion[0], y: state.quaternion[1], z: state.quaternion[2], w: state.quaternion[3] }
                        },
                        views: [{
                            eye: 'left', // Monoscopic
                            projectionMatrix: [1.2, 0, 0, 0, 0, 2.4, 0, 0, 0, 0, -1, -1, 0, 0, -0.2, 0],
                            transform: { position: {x:0,y:0,z:0}, orientation: {x:0,y:0,z:0,w:1} },
                            viewport: { x: 0, y: 0, width: width, height: height }
                        }]
                    };
                }
                
                // --- コントローラーのトラッキングデータを提供する ---
                getPose(inputSource, refSpace) {
                    const hand = inputSource.handedness;
                    const input = state.inputs[hand];

                    return {
                        transform: {
                            position: { x: input.position[0], y: input.position[1], z: input.position[2], w: 1 },
                            orientation: { x: input.quaternion[0], y: input.quaternion[1], z: input.quaternion[2], w: input.quaternion[3] }
                        },
                        // WebXR標準の`getPose`の返り値を満たすために、他のダミープロパティも追加
                        linearVelocity: {x:0, y:0, z:0},
                        angularVelocity: {x:0, y:0, z:0},
                        matrix: new Float32Array(16) 
                    };
                }

                updateRenderState(params) { 
                    if(params.baseLayer) this.renderState.baseLayer = params.baseLayer;
                }

                requestAnimationFrame(callback) {
                    if (this.ended) return 0;
                    return window.requestAnimationFrame((t) => {
                        callback(t, { 
                            session: this, 
                            getViewerPose: (refSpace) => this.getViewerPose(refSpace),
                            getPose: (inputSource, refSpace) => this.getPose(inputSource, refSpace)
                        });
                    });
                }
                
                end() { this.ended = true; return Promise.resolve(); }
                addEventListener() {}
                removeEventListener() {}
            }

            const mockXR = {
                isSessionSupported: (mode) => Promise.resolve(mode === 'immersive-vr'),
                requestSession: (mode) => {
                    if (mode !== 'immersive-vr') return Promise.reject(new Error('Only immersive-vr mode is mocked.'));
                    return Promise.resolve(new MockXRSession());
                }
            };

            try {
                Object.defineProperty(navigator, 'xr', { value: mockXR, configurable: true, writable: true });
            } catch(e) {
                window.navigator.xr = mockXR;
            }
        })();
        <\/script>
        `;

        // === 2. Editor & System Logic (ホスト/親ウィンドウ) ===

        const codeArea = document.getElementById('code-area');
        const slotSelect = document.getElementById('slot-select');
        const editorScreen = document.getElementById('editor-screen');
        const emulatorScreen = document.getElementById('emulator-screen');
        const vrFrame = document.getElementById('vr-frame');
        
        // デフォルトのサンプルコード（Three.js）
        const DEFAULT_CODE = `<!DOCTYPE html>
<html>
<head>
  <style>body { margin: 0; background: #000; }</style>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';

    // シーン設定
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; 
    document.body.appendChild(renderer.domElement);
    
    // コントローラー用のジオメトリ
    const controllerGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.2, 8);
    const controllerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const controller1 = new THREE.Mesh(controllerGeometry, controllerMaterial);
    const controller2 = new THREE.Mesh(controllerGeometry.clone(), controllerMaterial.clone());
    scene.add(controller1, controller2);

    // オブジェクト作成 (HMD基準)
    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(0, 1.6, -1);
    scene.add(cube);
    
    const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
    scene.add( light );
    
    // アニメーションループ
    renderer.setAnimationLoop((time, frame) => {
        if (frame) {
            // コントローラー位置の取得
            const session = renderer.xr.getSession();
            if (session && session.inputSources.length >= 2) {
                const referenceSpace = renderer.xr.getReferenceSpace();

                // 左手
                let poseL = frame.getPose(session.inputSources[0], referenceSpace);
                if (poseL) {
                    controller1.position.set(poseL.transform.position.x, poseL.transform.position.y, poseL.transform.position.z);
                    controller1.quaternion.set(poseL.transform.orientation.x, poseL.transform.orientation.y, poseL.transform.orientation.z, poseL.transform.orientation.w);
                    controller1.material.color.set(session.inputSources[0].gamepad.buttons[0].pressed ? 0x00ff00 : 0xff0000);
                }

                // 右手
                let poseR = frame.getPose(session.inputSources[1], referenceSpace);
                if (poseR) {
                    controller2.position.set(poseR.transform.position.x, poseR.transform.position.y, poseR.transform.position.z);
                    controller2.quaternion.set(poseR.transform.orientation.x, poseR.transform.orientation.y, poseR.transform.orientation.z, poseR.transform.orientation.w);
                    controller2.material.color.set(session.inputSources[1].gamepad.buttons[0].pressed ? 0x00ff00 : 0xff0000);
                }
            }
        }

        // カメラがHMDの位置と姿勢に追従
        renderer.render(scene, camera);
    });

    const startVR = async () => {
      if (navigator.xr) {
        try {
          const session = await navigator.xr.requestSession('immersive-vr');
          renderer.xr.setSession(session);
        } catch (e) { console.error("XR Start failed", e); }
      }
    };
    setTimeout(startVR, 100); 

  <\/script>
</head>
<body></body>
</html>`;

        // --- LocalStorage/Clipboard Functions (省略) ---
        window.onload = () => {
            loadSlot();
            if(!codeArea.value) codeArea.value = DEFAULT_CODE;
        };

        function saveSlot() {
            const slot = slotSelect.value;
            localStorage.setItem(`vr_emu_slot_${slot}`, codeArea.value);
            alert(`Slot ${slot} に保存しました`);
        }

        function loadSlot() {
            const slot = slotSelect.value;
            const data = localStorage.getItem(`vr_emu_slot_${slot}`);
            if (data) codeArea.value = data;
        }

        function clearCode() {
            if(confirm('エディタをクリアしますか？')) codeArea.value = '';
        }

        async function copyCode() {
            try {
                await navigator.clipboard.writeText(codeArea.value);
                alert('コピーしました');
            } catch (err) { alert('コピー失敗: ' + err); }
        }

        async function pasteCode() {
            try {
                const text = await navigator.clipboard.readText();
                codeArea.value = text;
            } catch (err) { alert('ペースト失敗: ' + err); }
        }
        
        // --- Run & Emulator Logic ---

        // HMD Pose
        let pose = { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 };
        // Controller Pose (位置 X, Y, Z)
        let controllerPose = {
            left: { x: -0.3, y: 1.4, z: -0.5, qx: 0, qy: 0, qz: 0, qw: 1 },
            right: { x: 0.3, y: 1.4, z: -0.5, qx: 0, qy: 0, qz: 0, qw: 1 }
        };

        let initialGyroAlpha = null;
        let animationFrameId;

        const postMessageToIframe = (message) => {
            if (vrFrame.contentWindow) {
                vrFrame.contentWindow.postMessage(Object.assign(message, { source: 'VR_HOST' }), '*');
            }
        };

        async function runVR() {
            let gyroGranted = true;
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const state = await DeviceOrientationEvent.requestPermission();
                    if (state !== 'granted') gyroGranted = false;
                } catch(e) { gyroGranted = false; }
            }
            startEmulator(gyroGranted);
        }

        function startEmulator(gyroGranted) {
            editorScreen.style.display = 'none';
            emulatorScreen.style.display = 'block';
            
            const userCode = codeArea.value;
            const finalHtml = userCode.replace('<head>', '<head>' + MOCK_LIB_CODE);
            
            vrFrame.srcdoc = finalHtml;

            if (gyroGranted) {
                window.addEventListener('deviceorientation', handleOrientation);
                document.getElementById('gyro-status').textContent = 'Gyro: ON (Active)';
            } else {
                document.getElementById('gyro-status').textContent = 'Gyro: OFF (Touch Tracking)';
            }

            startLoop();
        }

        function exitVR() {
            emulatorScreen.style.display = 'none';
            editorScreen.style.display = 'flex';
            vrFrame.srcdoc = '';
            window.removeEventListener('deviceorientation', handleOrientation);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            pose = { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 }; 
            controllerPose = {
                left: { x: -0.3, y: 1.4, z: -0.5, qx: 0, qy: 0, qz: 0, qw: 1 },
                right: { x: 0.3, y: 1.4, z: -0.5, qx: 0, qy: 0, qz: 0, qw: 1 }
            };
            initialGyroAlpha = null;
        }

        // --- Orientation & Tracking (HMD) ---

        function handleOrientation(e) {
            if(!initialGyroAlpha && e.alpha !== null) initialGyroAlpha = e.alpha;
            
            if(e.alpha !== null) {
                const radA = (e.alpha - initialGyroAlpha) * (Math.PI / 180);
                const radB = (e.beta !== null ? e.beta - 90 : 0) * (Math.PI / 180);
                pose.yaw = -radA; 
                pose.pitch = radB;
            }
        }
        
        let startX, startY, touchDrag;
        const ROTATION_FACTOR = 0.005; 
        
        emulatorScreen.addEventListener('touchstart', (e) => {
            if (e.target.closest('#controls-overlay')) return; 
            touchDrag = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            e.preventDefault();
        });

        emulatorScreen.addEventListener('touchmove', (e) => {
            if(!touchDrag || e.target.closest('#controls-overlay')) return;
            e.preventDefault();
            
            if(document.getElementById('gyro-status').textContent.includes('Touch Tracking')) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;

                pose.yaw += deltaX * ROTATION_FACTOR;
                pose.pitch += deltaY * ROTATION_FACTOR;
                pose.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pose.pitch));

                startX = touch.clientX;
                startY = touch.clientY;
            }
        });
        emulatorScreen.addEventListener('touchend', () => { touchDrag = false; });


        // --- Input Handling (Joystick & Buttons) ---
        
        const joyZone = document.getElementById('joystick-area');
        const joyKnob = document.getElementById('joystick-knob');
        let joyDrag = false;
        let joyCenter = {x:0, y:0};
        
        // Joystick (HMD Movement)
        joyZone.addEventListener('touchstart', e => {
            joyDrag = true;
            const rect = joyZone.getBoundingClientRect();
            joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        }, {passive: false});

        joyZone.addEventListener('touchmove', e => {
            if(!joyDrag) return;
            e.preventDefault();
            const t = e.touches[0];
            const maxR = 35;
            let dx = t.clientX - joyCenter.x;
            let dy = t.clientY - joyCenter.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist > maxR) { dx = dx * (maxR/dist); dy = dy * (maxR/dist); }
            
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            
            const ax = dx / maxR;
            const ay = dy / maxR;
            
            const speed = 0.05;
            const forward = -ay * speed;
            const sideways = ax * speed; 
            
            pose.x += Math.sin(pose.yaw) * forward + Math.cos(pose.yaw) * sideways;
            pose.z += Math.cos(pose.yaw) * forward - Math.sin(pose.yaw) * sideways;

            postMessageToIframe({ type: 'updateInput', hand: 'left', axes: [ax, ay] });
        }, {passive: false});

        const resetJoy = () => {
            joyDrag = false;
            joyKnob.style.transform = `translate(-50%, -50%)`;
            postMessageToIframe({ type: 'updateInput', hand: 'left', axes: [0, 0] });
        };
        joyZone.addEventListener('touchend', resetJoy);
        joyZone.addEventListener('touchcancel', resetJoy);

        // Buttons
        document.querySelectorAll('.v-btn').forEach(btn => {
            const key = btn.dataset.key;
            const hand = btn.dataset.hand;

            const send = (pressed) => {
                const msg = { type: 'updateInput', hand: hand, buttons: {} };
                msg.buttons[key] = pressed;
                postMessageToIframe(msg);
            };
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); send(true); });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); send(false); });
        });

        // --- Controller Tracking Pads ---
        
        const TRACK_SCALE = 0.005; // トラッキング感度

        function setupTrackingPad(padId, hand) {
            const pad = document.getElementById(padId);
            let isTracking = false;
            let startClientX, startClientY;
            let startX, startY;

            pad.addEventListener('touchstart', e => {
                isTracking = true;
                e.preventDefault();
                startClientX = e.touches[0].clientX;
                startClientY = e.touches[0].clientY;
                startX = controllerPose[hand].x;
                startY = controllerPose[hand].y;
            }, {passive: false});

            pad.addEventListener('touchmove', e => {
                if(!isTracking) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - startClientX;
                const dy = touch.clientY - startClientY;
                
                // X座標 (左右) と Z座標 (前後) を操作 (Yは高さ固定)
                controllerPose[hand].x = startX + dx * TRACK_SCALE;
                controllerPose[hand].z = controllerPose[hand].z + dy * TRACK_SCALE; // YタッチはZ移動へ
                
                // コントローラーの姿勢はここでは回転しない（固定）
            }, {passive: false});

            const stopTracking = () => {
                isTracking = false;
            };
            pad.addEventListener('touchend', stopTracking);
            pad.addEventListener('touchcancel', stopTracking);
        }

        setupTrackingPad('left-tracking-pad', 'left');
        setupTrackingPad('right-tracking-pad', 'right');

        // --- Main Loop (Pose Data Transmission) ---

        function startLoop() {
            function loop() {
                if(emulatorScreen.style.display === 'none') return;

                // HMD Pose (Euler to Quaternion)
                const c1 = Math.cos(pose.yaw / 2); const s1 = Math.sin(pose.yaw / 2);
                const c2 = Math.cos(pose.pitch / 2); const s2 = Math.sin(pose.pitch / 2);
                const c3 = Math.cos(0); const s3 = Math.sin(0);
                const qw = c1 * c2 * c3 + s1 * s2 * s3; 
                const qx = c1 * s2 * c3 + s1 * c2 * s3; 
                const qy = s1 * c2 * c3 - c1 * s2 * s3; 
                const qz = c1 * c2 * s3 - s1 * s2 * c3; 

                postMessageToIframe({
                    type: 'updatePose',
                    position: [pose.x, pose.y, pose.z],
                    quaternion: [qx, qy, qz, qw],
                    // コントローラーのトラッキングデータを追加
                    handPose: {
                        hand: 'left',
                        position: [controllerPose.left.x, controllerPose.left.y, controllerPose.left.z],
                        quaternion: [controllerPose.left.qx, controllerPose.left.qy, controllerPose.left.qz, controllerPose.left.qw]
                    }
                });
                
                postMessageToIframe({
                    type: 'updatePose',
                    handPose: {
                        hand: 'right',
                        position: [controllerPose.right.x, controllerPose.right.y, controllerPose.right.z],
                        quaternion: [controllerPose.right.qx, controllerPose.right.qy, controllerPose.right.qz, controllerPose.right.qw]
                    }
                });

                animationFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

    </script>
</body>
</html>
